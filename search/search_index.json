{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Curso flask (Miniframework python para desarrollar p\u00e1ginas web) \u00b6 Flask es un \u201cmicro\u201d framework escrito en Python y concebido para facilitar el desarrollo de aplicaciones Web bajo el patr\u00f3n MVC. Los siguientes contenidos forman parte de un curso que he impartido para OpenWebinars en septiembre de 2016. Puedes obtener todo el contenido del curso en el repositorio GitHub. Todas las observaciones, mejoras y sugerencias son bienvenidas. Unidades \u00b6 Introducci\u00f3n al curso Introducci\u00f3n a la programaci\u00f3n web 2.1 Protocolo HTTP 2.2 Programaci\u00f3n web din\u00e1mica 2.3 Patr\u00f3n modelo-vista-controlador Introducci\u00f3n a la programaci\u00f3n web con python 3.1 Introducci\u00f3n a flask 3.2 Instalaci\u00f3n de flask 3.3 Corriendo una aplicaci\u00f3n sencilla Controlador: Enrutamiento, peticiones y respuestas 4.1 Enrutamiento: Rutas 4.2 Enrutamiento: M\u00e9todos 4.3 Trabajando con peticiones HTTP 4.4 Generando respuestas HTTP, respuestas de error y redirecciones 4.5 Contenido est\u00e1tico 4.6 Ejercicios Vista: Plantillas y formularios 5.1 Plantillas con jinja2 5.2 Generando p\u00e1ginas HTML con Flask y Jinja2 5.3 Herencia de plantillas 5.4 Plantillas con bootstrap (flask-bootstrap) 5.5 Trabajando con formularios 5.6 Generando formularios con flask-wtf 5.7 Subida de ficheros Modelo: Gestionando los datos 6.1 Usando base de datos en Flask, flask-sqlalchemy 6.2 El modelo de base de datos 6.3 Listando y filtrando los registros de la base de datos 6.4 Creando registros en la base de datos 6.5 Modificando registros en la base de datos 6.6 Borrando un registro de la base de datos Gesti\u00f3n de usuarios 7.1 Gesti\u00f3n de usuarios con sesiones 7.2 Registrando nuevos usuarios 7.3 Gesti\u00f3n de permisos de usuarios 7.4 Gesti\u00f3n de usuarios con extensi\u00f3n Flask-Login Gesti\u00f3n carrito de la compra 8.1 Uso de cookies para a\u00f1adir art\u00edculos al carrito 8.2. Finalizaci\u00f3n de la compra Despliegue de la aplicaci\u00f3n 9.1 Despliegue de aplicaci\u00f3n flask en un servidor LAMP 9.2 Despliegue de aplicaci\u00f3n flask en hosting pythonanywhere 9.3 Despliegue de aplicaci\u00f3n flask en un PaaS Heroku 9.4 Despliegue de aplicaci\u00f3n flask en un contenedor docker","title":"1. INTRODUCCI\u00d3N AL CURSO"},{"location":"index.html#curso-flask-miniframework-python-para-desarrollar-paginas-web","text":"Flask es un \u201cmicro\u201d framework escrito en Python y concebido para facilitar el desarrollo de aplicaciones Web bajo el patr\u00f3n MVC. Los siguientes contenidos forman parte de un curso que he impartido para OpenWebinars en septiembre de 2016. Puedes obtener todo el contenido del curso en el repositorio GitHub. Todas las observaciones, mejoras y sugerencias son bienvenidas.","title":"Curso flask (Miniframework python para desarrollar p\u00e1ginas web)"},{"location":"index.html#unidades","text":"Introducci\u00f3n al curso Introducci\u00f3n a la programaci\u00f3n web 2.1 Protocolo HTTP 2.2 Programaci\u00f3n web din\u00e1mica 2.3 Patr\u00f3n modelo-vista-controlador Introducci\u00f3n a la programaci\u00f3n web con python 3.1 Introducci\u00f3n a flask 3.2 Instalaci\u00f3n de flask 3.3 Corriendo una aplicaci\u00f3n sencilla Controlador: Enrutamiento, peticiones y respuestas 4.1 Enrutamiento: Rutas 4.2 Enrutamiento: M\u00e9todos 4.3 Trabajando con peticiones HTTP 4.4 Generando respuestas HTTP, respuestas de error y redirecciones 4.5 Contenido est\u00e1tico 4.6 Ejercicios Vista: Plantillas y formularios 5.1 Plantillas con jinja2 5.2 Generando p\u00e1ginas HTML con Flask y Jinja2 5.3 Herencia de plantillas 5.4 Plantillas con bootstrap (flask-bootstrap) 5.5 Trabajando con formularios 5.6 Generando formularios con flask-wtf 5.7 Subida de ficheros Modelo: Gestionando los datos 6.1 Usando base de datos en Flask, flask-sqlalchemy 6.2 El modelo de base de datos 6.3 Listando y filtrando los registros de la base de datos 6.4 Creando registros en la base de datos 6.5 Modificando registros en la base de datos 6.6 Borrando un registro de la base de datos Gesti\u00f3n de usuarios 7.1 Gesti\u00f3n de usuarios con sesiones 7.2 Registrando nuevos usuarios 7.3 Gesti\u00f3n de permisos de usuarios 7.4 Gesti\u00f3n de usuarios con extensi\u00f3n Flask-Login Gesti\u00f3n carrito de la compra 8.1 Uso de cookies para a\u00f1adir art\u00edculos al carrito 8.2. Finalizaci\u00f3n de la compra Despliegue de la aplicaci\u00f3n 9.1 Despliegue de aplicaci\u00f3n flask en un servidor LAMP 9.2 Despliegue de aplicaci\u00f3n flask en hosting pythonanywhere 9.3 Despliegue de aplicaci\u00f3n flask en un PaaS Heroku 9.4 Despliegue de aplicaci\u00f3n flask en un contenedor docker","title":"Unidades"},{"location":"2_1_protocolo_http.html","text":"Protocolo HTTP \u00b6 Presentaci\u00f3n de la Unidad Descripci\u00f3n general \u00b6 Protocolo de comunicaciones est\u00e1ndar que comunica servidores, proxys y clientes. Permite la transferencia de documentos web, sin importar cual es el cliente o cual es el servidor. Es un protocolo basado en el esquema petici\u00f3n/respuesta. El cliente realiza una petici\u00f3n y el servido devuelve una respuesta. El protocolo HTTP est\u00e1 basado en mensajes de texto plano y es un protocolo sin manejo de estados. Funcionamiento del protocolo \u00b6 El usuario escribe una URL, indicando el protocolo, servidor y recurso que quiere obtener, el servidor procesa dicha informaci\u00f3n y devuelve un mensaje de respuesta, normalmente con el HTML de la p\u00e1gina que se va a visualizar,\u2026 El contenido del mensaje seg\u00fan sea la petici\u00f3n o la respuesta lo podemos ver en el siguiente esquema: M\u00e9todos de env\u00edo de los datos \u00b6 Cuando se realiza una petici\u00f3n se puede utilizar uno de los siguientes m\u00e9todos: GET: Solicita un documento al servidor. Se pueden enviar datos en la URL. HEAD: Similar a GET, pero s\u00f3lo pide las cabeceras HTTP. POST: Manda datos al servidor para su procesado.Similar a GET, pero adem\u00e1s env\u00eda datos en el cuerpo del mensaje. PUT: Almacena el documento enviado en el cuerpo del mensaje. DELETE: Elimina el documento referenciado en la URL. \u2026 C\u00f3digo de estados Cuando el servidor devuelve una respuesta se indica un c\u00f3digo de estado: Cabeceras \u00b6 Tanto la petici\u00f3n como las respuestas tienen una serie de metainformaci\u00f3n llamadas cabeceras, podemos indicar las m\u00e1s importantes: Server: indica el tipo de servidor HTTP empleado. Age: indica el tiempo que ha estado el objeto servido almacenado en un proxy cache (en segundos) Cache-control: lo usa el servidor para decirle al navegador que objetos cachear, durante cuanto tiempo, etc.. Content-Encoding: se indica el tipo de codificaci\u00f3n empleado en la respuesta Expires: indica una fecha y hora a partir del cual la respuesta HTTP se considera obsoleta. Usado para gestionar cach\u00e9. Location: usado para especificar una nueva ubicaci\u00f3n en casos de redirecciones. Set-Cookie: sirve para crear cookies. Las famosos cookies viajan entre el servidor y el navegador a trav\u00e9s de estas cabeceras HTTP. Cookies \u00b6 Las cookie son informaci\u00f3n que el navegador guarda en memoria o en el disco duro dentro de ficheros de texto, a solicitud del servidor. Incluyen datos generados por el servidor, o datos introducidos en un formulario por el usuario, enviados al servidor y reenviados por \u00e9ste al cliente. HTTP es un protocolo sin estados (no almacena el estado de la sesi\u00f3n entre peticiones sucesivas), las cookies pueden usarse para asociar estado. Proporcionan una manera de conservar cierta informaci\u00f3n entre peticiones del cliente. Ejemplos de uso: Guarda informaci\u00f3n de la sesi\u00f3n. Comercio electr\u00f3nico. Carrito de la compra. Personalizaci\u00f3n de p\u00e1ginas Idiomas Seguimiento de las visitas a un Web Carteles publicitarios Almacenamiento del login y password Sesiones \u00b6 HTTP es un protocolo sin manejo de estados. Las sesiones son fundamentales en las aplicaciones Web. Permiten: Definir varios estados distintos en la aplicaci\u00f3n. Colocar las solicitudes y respuestas dentro de un contexto m\u00e1s amplio. Los clientes y servidores intercambian informaci\u00f3n sobre el estado de la aplicaci\u00f3n. El servidor almacenar\u00e1 la informaci\u00f3n necesaria para llevar el seguimiento de la sesi\u00f3n. - Identificador de la sesi\u00f3n. - Identificador del usuario en sesi\u00f3n. - Tiempo de expiraci\u00f3n de la sesi\u00f3n. - Variables asociadas a la sesi\u00f3n. El mecanismo m\u00e1s usual para permitir las sesiones es por medio de las cookie, guardando el identificador de la sesi\u00f3n.","title":"2.1. Protocolo HTTP"},{"location":"2_1_protocolo_http.html#protocolo-http","text":"Presentaci\u00f3n de la Unidad","title":"Protocolo HTTP"},{"location":"2_1_protocolo_http.html#descripcion-general","text":"Protocolo de comunicaciones est\u00e1ndar que comunica servidores, proxys y clientes. Permite la transferencia de documentos web, sin importar cual es el cliente o cual es el servidor. Es un protocolo basado en el esquema petici\u00f3n/respuesta. El cliente realiza una petici\u00f3n y el servido devuelve una respuesta. El protocolo HTTP est\u00e1 basado en mensajes de texto plano y es un protocolo sin manejo de estados.","title":"Descripci\u00f3n general"},{"location":"2_1_protocolo_http.html#funcionamiento-del-protocolo","text":"El usuario escribe una URL, indicando el protocolo, servidor y recurso que quiere obtener, el servidor procesa dicha informaci\u00f3n y devuelve un mensaje de respuesta, normalmente con el HTML de la p\u00e1gina que se va a visualizar,\u2026 El contenido del mensaje seg\u00fan sea la petici\u00f3n o la respuesta lo podemos ver en el siguiente esquema:","title":"Funcionamiento del protocolo"},{"location":"2_1_protocolo_http.html#metodos-de-envio-de-los-datos","text":"Cuando se realiza una petici\u00f3n se puede utilizar uno de los siguientes m\u00e9todos: GET: Solicita un documento al servidor. Se pueden enviar datos en la URL. HEAD: Similar a GET, pero s\u00f3lo pide las cabeceras HTTP. POST: Manda datos al servidor para su procesado.Similar a GET, pero adem\u00e1s env\u00eda datos en el cuerpo del mensaje. PUT: Almacena el documento enviado en el cuerpo del mensaje. DELETE: Elimina el documento referenciado en la URL. \u2026 C\u00f3digo de estados Cuando el servidor devuelve una respuesta se indica un c\u00f3digo de estado:","title":"M\u00e9todos de env\u00edo de los datos"},{"location":"2_1_protocolo_http.html#cabeceras","text":"Tanto la petici\u00f3n como las respuestas tienen una serie de metainformaci\u00f3n llamadas cabeceras, podemos indicar las m\u00e1s importantes: Server: indica el tipo de servidor HTTP empleado. Age: indica el tiempo que ha estado el objeto servido almacenado en un proxy cache (en segundos) Cache-control: lo usa el servidor para decirle al navegador que objetos cachear, durante cuanto tiempo, etc.. Content-Encoding: se indica el tipo de codificaci\u00f3n empleado en la respuesta Expires: indica una fecha y hora a partir del cual la respuesta HTTP se considera obsoleta. Usado para gestionar cach\u00e9. Location: usado para especificar una nueva ubicaci\u00f3n en casos de redirecciones. Set-Cookie: sirve para crear cookies. Las famosos cookies viajan entre el servidor y el navegador a trav\u00e9s de estas cabeceras HTTP.","title":"Cabeceras"},{"location":"2_1_protocolo_http.html#cookies","text":"Las cookie son informaci\u00f3n que el navegador guarda en memoria o en el disco duro dentro de ficheros de texto, a solicitud del servidor. Incluyen datos generados por el servidor, o datos introducidos en un formulario por el usuario, enviados al servidor y reenviados por \u00e9ste al cliente. HTTP es un protocolo sin estados (no almacena el estado de la sesi\u00f3n entre peticiones sucesivas), las cookies pueden usarse para asociar estado. Proporcionan una manera de conservar cierta informaci\u00f3n entre peticiones del cliente. Ejemplos de uso: Guarda informaci\u00f3n de la sesi\u00f3n. Comercio electr\u00f3nico. Carrito de la compra. Personalizaci\u00f3n de p\u00e1ginas Idiomas Seguimiento de las visitas a un Web Carteles publicitarios Almacenamiento del login y password","title":"Cookies"},{"location":"2_1_protocolo_http.html#sesiones","text":"HTTP es un protocolo sin manejo de estados. Las sesiones son fundamentales en las aplicaciones Web. Permiten: Definir varios estados distintos en la aplicaci\u00f3n. Colocar las solicitudes y respuestas dentro de un contexto m\u00e1s amplio. Los clientes y servidores intercambian informaci\u00f3n sobre el estado de la aplicaci\u00f3n. El servidor almacenar\u00e1 la informaci\u00f3n necesaria para llevar el seguimiento de la sesi\u00f3n. - Identificador de la sesi\u00f3n. - Identificador del usuario en sesi\u00f3n. - Tiempo de expiraci\u00f3n de la sesi\u00f3n. - Variables asociadas a la sesi\u00f3n. El mecanismo m\u00e1s usual para permitir las sesiones es por medio de las cookie, guardando el identificador de la sesi\u00f3n.","title":"Sesiones"},{"location":"2_2_web_dinamica.html","text":"Programaci\u00f3n web din\u00e1mica \u00b6 Presentaci\u00f3n de la Unidad P\u00e1ginas web din\u00e1micas \u00b6 Las p\u00e1ginas web din\u00e1micas son aquellas en las que la informaci\u00f3n presentada se genera a partir de una petici\u00f3n del usuario de la p\u00e1gina. Contrariamente a lo que ocurre con las p\u00e1ginas est\u00e1ticas, en las que su contenido se encuentra predeterminado, en las p\u00e1ginas din\u00e1micas la informaci\u00f3n aparece inmediatamente despu\u00e9s de una solicitud echa por el usuario. El resultado de la p\u00e1gina obtenida en la respuesta depender\u00e1 de varios aspectos: informaci\u00f3n guardada en la base de datos, contenido de una cookie o sesi\u00f3n, par\u00e1metros en la petici\u00f3n HTTP,\u2026 Procesamiento de p\u00e1ginas din\u00e1micas \u00b6 Cuando el servidor Web recibe una petici\u00f3n para mostrar una p\u00e1gina din\u00e1mica, transfiere la p\u00e1gina a un software especial encargado de finalizar la p\u00e1gina. Este software especial se denomina servidor de aplicaciones. El servidor de aplicaciones, seg\u00fan la petici\u00f3n que se ha realizado ejecuta un programa en un lenguaje de programaci\u00f3n determinado y devuelve una respuesta HTTP, cuyo contenido normalmente es una p\u00e1gina HTML. Esquem\u00e1ticamente lo podemos ver de la siguiente manera: Acceso a una base de datos \u00b6 Un servidor de aplicaciones le permite trabajar con recursos del lado del servidor, como las bases de datos. Por ejemplo, una p\u00e1gina din\u00e1mica puede indicar al servidor de aplicaciones que extraiga datos de una base de datos y los inserte en el c\u00f3digo HTML de la p\u00e1gina. El uso de una base de datos para almacenar contenido permite separar el dise\u00f1o del sitio Web del contenido que se desea mostrar a los usuarios del sitio. En lugar de escribir archivos HTML individuales para cada p\u00e1gina, s\u00f3lo se necesita escribir una p\u00e1gina \u2014o plantilla\u2014 para presentar los datos de la base de datos al usuario. Tambi\u00e9n de forma din\u00e1mica se puede presentar formularios HTML que a\u00f1adan o modifiquen informaci\u00f3n en la base de datos. Esquem\u00e1ticamente lo podemos ver de la siguiente manera: Programaci\u00f3n web din\u00e1mica con python \u00b6 Como lenguaje de programaci\u00f3n web vamos a utilizar Python, como servidor de aplicaciones vamos a usar el concepto de WSGI (Web Server Gateway Interface), que es una especificaci\u00f3n de una interface simple y universal entre los servidores web y las aplicaciones web o frameworks desarrolladas con python. En concreto usaremos un framework python (llamado Flask) para desarrollar aplicaciones web din\u00e1micas siguiendo el patr\u00f3n de modelo-vista-controlador. Estos conceptos los estudiaremos en la siguientes unidades.","title":"2.2 Programaci\u00f3n web din\u00e1mica"},{"location":"2_2_web_dinamica.html#programacion-web-dinamica","text":"Presentaci\u00f3n de la Unidad","title":"Programaci\u00f3n web din\u00e1mica"},{"location":"2_2_web_dinamica.html#paginas-web-dinamicas","text":"Las p\u00e1ginas web din\u00e1micas son aquellas en las que la informaci\u00f3n presentada se genera a partir de una petici\u00f3n del usuario de la p\u00e1gina. Contrariamente a lo que ocurre con las p\u00e1ginas est\u00e1ticas, en las que su contenido se encuentra predeterminado, en las p\u00e1ginas din\u00e1micas la informaci\u00f3n aparece inmediatamente despu\u00e9s de una solicitud echa por el usuario. El resultado de la p\u00e1gina obtenida en la respuesta depender\u00e1 de varios aspectos: informaci\u00f3n guardada en la base de datos, contenido de una cookie o sesi\u00f3n, par\u00e1metros en la petici\u00f3n HTTP,\u2026","title":"P\u00e1ginas web din\u00e1micas"},{"location":"2_2_web_dinamica.html#procesamiento-de-paginas-dinamicas","text":"Cuando el servidor Web recibe una petici\u00f3n para mostrar una p\u00e1gina din\u00e1mica, transfiere la p\u00e1gina a un software especial encargado de finalizar la p\u00e1gina. Este software especial se denomina servidor de aplicaciones. El servidor de aplicaciones, seg\u00fan la petici\u00f3n que se ha realizado ejecuta un programa en un lenguaje de programaci\u00f3n determinado y devuelve una respuesta HTTP, cuyo contenido normalmente es una p\u00e1gina HTML. Esquem\u00e1ticamente lo podemos ver de la siguiente manera:","title":"Procesamiento de p\u00e1ginas din\u00e1micas"},{"location":"2_2_web_dinamica.html#acceso-a-una-base-de-datos","text":"Un servidor de aplicaciones le permite trabajar con recursos del lado del servidor, como las bases de datos. Por ejemplo, una p\u00e1gina din\u00e1mica puede indicar al servidor de aplicaciones que extraiga datos de una base de datos y los inserte en el c\u00f3digo HTML de la p\u00e1gina. El uso de una base de datos para almacenar contenido permite separar el dise\u00f1o del sitio Web del contenido que se desea mostrar a los usuarios del sitio. En lugar de escribir archivos HTML individuales para cada p\u00e1gina, s\u00f3lo se necesita escribir una p\u00e1gina \u2014o plantilla\u2014 para presentar los datos de la base de datos al usuario. Tambi\u00e9n de forma din\u00e1mica se puede presentar formularios HTML que a\u00f1adan o modifiquen informaci\u00f3n en la base de datos. Esquem\u00e1ticamente lo podemos ver de la siguiente manera:","title":"Acceso a una base de datos"},{"location":"2_2_web_dinamica.html#programacion-web-dinamica-con-python","text":"Como lenguaje de programaci\u00f3n web vamos a utilizar Python, como servidor de aplicaciones vamos a usar el concepto de WSGI (Web Server Gateway Interface), que es una especificaci\u00f3n de una interface simple y universal entre los servidores web y las aplicaciones web o frameworks desarrolladas con python. En concreto usaremos un framework python (llamado Flask) para desarrollar aplicaciones web din\u00e1micas siguiendo el patr\u00f3n de modelo-vista-controlador. Estos conceptos los estudiaremos en la siguientes unidades.","title":"Programaci\u00f3n web din\u00e1mica con python"},{"location":"2_3_mvc.html","text":"Patr\u00f3n modelo-vista-controlador \u00b6 Presentaci\u00f3n de la Unidad Modelo\u2013vista\u2013controlador (MVC) es un patr\u00f3n de arquitectura de software, que separa los datos y la l\u00f3gica de negocio de una aplicaci\u00f3n de la interfaz de usuario y el m\u00f3dulo encargado de gestionar los eventos y las comunicaciones. Para ello MVC propone la construcci\u00f3n de tres componentes distintos que son el modelo, la vista y el controlador. El Modelo: Es la representaci\u00f3n de la informaci\u00f3n con la cual el sistema opera, por lo tanto gestiona todos los accesos a dicha informaci\u00f3n, tanto consultas como actualizaciones, implementando tambi\u00e9n los privilegios de acceso que se hayan descrito en las especificaciones de la aplicaci\u00f3n (l\u00f3gica de negocio). El Controlador: Responde a eventos (usualmente acciones del usuario) e invoca peticiones al \u2018modelo\u2019 cuando se hace alguna solicitud sobre la informaci\u00f3n (por ejemplo, editar un documento o un registro en una base de datos). Tambi\u00e9n puede enviar comandos a su \u2018vista\u2019 asociada si se solicita un cambio en la forma en que se presenta el \u2018modelo\u2019, por tanto se podr\u00eda decir que el \u2018controlador\u2019 hace de intermediario entre la \u2018vista\u2019 y el \u2018modelo\u2019. La Vista: Presenta el \u2018modelo\u2019 (informaci\u00f3n y l\u00f3gica de negocio) en un formato adecuado para interactuar (usualmente la interfaz de usuario) por tanto requiere de dicho \u2018modelo\u2019 la informaci\u00f3n que debe representar como salida. Flask y MVC \u00b6 Flask es totalmente compatible con el patr\u00f3n MVC: Aunque por defecto no tiene un ORM, podemos usar una extensi\u00f3n de Flask para definir el modelo de datos. Esta caracter\u00edstica nos abstrae del uso del motor de Base de Datos y lo hace independiente. Con Flask vamos a definir un controlador, que es capaz de determinar las rutas con las que accedemos a la aplicaci\u00f3n, procesar la informaci\u00f3n necesaria y mostrar la informaci\u00f3n necesaria en cada momento. Flask utiliza jinja2 como motor de plantillas, con lo que es muy f\u00e1cil dise\u00f1ar las vistas que vamos a mostrar a los usuarios en cada momento. Las p\u00e1ginas web din\u00e1micas son aquellas en las que la informaci\u00f3n presentada se genera a partir de una petici\u00f3n del usuario de la p\u00e1gina.","title":"2.3 Patr\u00f3n modelo-vista-controlador"},{"location":"2_3_mvc.html#patron-modelo-vista-controlador","text":"Presentaci\u00f3n de la Unidad Modelo\u2013vista\u2013controlador (MVC) es un patr\u00f3n de arquitectura de software, que separa los datos y la l\u00f3gica de negocio de una aplicaci\u00f3n de la interfaz de usuario y el m\u00f3dulo encargado de gestionar los eventos y las comunicaciones. Para ello MVC propone la construcci\u00f3n de tres componentes distintos que son el modelo, la vista y el controlador. El Modelo: Es la representaci\u00f3n de la informaci\u00f3n con la cual el sistema opera, por lo tanto gestiona todos los accesos a dicha informaci\u00f3n, tanto consultas como actualizaciones, implementando tambi\u00e9n los privilegios de acceso que se hayan descrito en las especificaciones de la aplicaci\u00f3n (l\u00f3gica de negocio). El Controlador: Responde a eventos (usualmente acciones del usuario) e invoca peticiones al \u2018modelo\u2019 cuando se hace alguna solicitud sobre la informaci\u00f3n (por ejemplo, editar un documento o un registro en una base de datos). Tambi\u00e9n puede enviar comandos a su \u2018vista\u2019 asociada si se solicita un cambio en la forma en que se presenta el \u2018modelo\u2019, por tanto se podr\u00eda decir que el \u2018controlador\u2019 hace de intermediario entre la \u2018vista\u2019 y el \u2018modelo\u2019. La Vista: Presenta el \u2018modelo\u2019 (informaci\u00f3n y l\u00f3gica de negocio) en un formato adecuado para interactuar (usualmente la interfaz de usuario) por tanto requiere de dicho \u2018modelo\u2019 la informaci\u00f3n que debe representar como salida.","title":"Patr\u00f3n modelo-vista-controlador"},{"location":"2_3_mvc.html#flask-y-mvc","text":"Flask es totalmente compatible con el patr\u00f3n MVC: Aunque por defecto no tiene un ORM, podemos usar una extensi\u00f3n de Flask para definir el modelo de datos. Esta caracter\u00edstica nos abstrae del uso del motor de Base de Datos y lo hace independiente. Con Flask vamos a definir un controlador, que es capaz de determinar las rutas con las que accedemos a la aplicaci\u00f3n, procesar la informaci\u00f3n necesaria y mostrar la informaci\u00f3n necesaria en cada momento. Flask utiliza jinja2 como motor de plantillas, con lo que es muy f\u00e1cil dise\u00f1ar las vistas que vamos a mostrar a los usuarios en cada momento. Las p\u00e1ginas web din\u00e1micas son aquellas en las que la informaci\u00f3n presentada se genera a partir de una petici\u00f3n del usuario de la p\u00e1gina.","title":"Flask y MVC"},{"location":"2_4_intro_web_py.html","text":"Introducci\u00f3n a la programaci\u00f3n web con python \u00b6 Aunque de forma general se utilizan distintos framework (por ejemplo Flask) para el desarrollo de aplicaciones web con Python. En esta unidad voy a introducir los conceptos necesarios para crear una p\u00e1gina web desarrollada con python sin utilizar ning\u00fan framework. Para ello es necesario conocer el concepto de WSGI (Web Server Gateway Interface), que es una especificaci\u00f3n de una interface simple y universal entre los servidores web y las aplicaciones web o frameworks desarrolladas con python. Creaci\u00f3n de la aplicaci\u00f3n WSGI \u00b6 Todas las peticiones que hagamos a nuestro servidor estar\u00e1n manejadas por la aplicaci\u00f3n WSGI, que ser\u00e1 un \u00fanico fichero. Esta aplicaci\u00f3n ser\u00e1 la responsable de manejar las peticiones, y de devolver la respuesta adecuada seg\u00fan la URI solicitada. En esta aplicaci\u00f3n tendremos que definir una funci\u00f3n, que act\u00fae con cada petici\u00f3n del usuario. Esta funci\u00f3n, deber\u00e1 ser una funci\u00f3n WSGI aplicaci\u00f3n v\u00e1lida. Esto significa que: Deber\u00e1 llamarse application. Deber\u00e1 recibir dos par\u00e1metros: environ, del m\u00f3dulo os, que provee un diccionario de las peticiones HTTP est\u00e1ndar y otras variables de entorno, y la funci\u00f3n start_response, de WSGI, encargada de entregar la respuesta HTTP al usuario. Veamos el primer ejemplo wsgi1.py: wsgi1.py # -*- coding: utf-8 -*- def application ( environ , start_response ): # Guardo la salida que devolver\u00e9 como respuesta respuesta = \"<p>P\u00e1gina web construida con <strong>Python!!!</strong></p>\" # Se genera una respuesta al navegador start_response ( '200 OK' , [( 'Content-Type' , 'text/html; charset=utf-8' )]) return [ respuesta . encode ()] if __name__ == '__main__' : from wsgiref.simple_server import make_server srv = make_server ( 'localhost' , 8080 , application ) srv . serve_forever () Para ejecutar este programa ejecutamos: $ python wsgi1.py Se crear\u00e1 un servidor web que responder\u00e1 en localhost en el puerto 8080. Creando una aplicaci\u00f3n web un \u201cpoco m\u00e1s compleja\u201d \u00b6 El controlador que hemos hecho anteriormente no tiene en cuenta la URL con la que hemos accedido al servidor y siempre va a generar la misma respuesta. Utilizando la informaci\u00f3n sobre la petici\u00f3n que tenemos guardada en el diccionario environ podemos construir diferentes respuestas seg\u00fan la petici\u00f3n, por ejemplo teniendo en cuenta la URL de acceso. El diccionario environ que se recibe con cada pedido HTTP, contiene las variables est\u00e1ndar de la especificaci\u00f3n CGI, entre ellas: REQUEST_METHOD: m\u00e9todo \u201cGET\u201d, \u201cPOST\u201d, \u2026 SCRIPT_NAME: la parte inicial de la \u201cruta\u201d, que corresponde a la aplicaci\u00f3n PATH_INFO: la segunda parte de la \u201cruta\u201d, determina la \u201cubicaci\u00f3n\u201d virtual dentro de la aplicaci\u00f3n. QUERY_STRING: la porci\u00f3n de la URL que sigue al \u201c?\u201d, si existe CONTENT_TYPE, CONTENT_LENGTH de la petici\u00f3n HTTP SERVER_NAME, SERVER_PORT, que combinadas con SCRIPT_NAME y PATH_INFO dan la URL SERVER_PROTOCOL: la versi\u00f3n del protocolo (\u201cHTTP/1.0\u201d or \u201cHTTP/1.1\u201d) De esta forma podemos hacer un controlador (fichero wsgi2.py) de la siguiente manera, para comprobar la URL de acceso: wsgi2.py #-*- coding: utf-8 -*- def application ( environ , start_response ): if environ [ \"PATH_INFO\" ] == \"/\" : respuesta = \"<p>P\u00e1gina inicial</p>\" elif environ [ \"PATH_INFO\" ] == \"/hola\" : respuesta = \"<p>Bienvenidos a mi p\u00e1gina web</p>\" else : respuesta = \"<p><trong>P\u00e1gina incorrecta</strong></p>\" start_response ( '200 OK' , [( 'Content-Type' , 'text/html; charset=utf-8' )]) return [ respuesta . encode ()] if __name__ == '__main__' : from wsgiref.simple_server import make_server srv = make_server ( 'localhost' , 8080 , application ) srv . serve_forever () En este \u00faltimo ejemplo (fichero wsgi3.py) vamos a ver c\u00f3mo podemos trabajar con par\u00e1metros enviados por el m\u00e9todo GET: wsgi3.py # -*- coding: utf-8 -*- def application ( environ , start_response ): if environ [ \"PATH_INFO\" ] == \"/\" : respuesta = \"<p>P\u00e1gina inicial</p>\" elif environ [ \"PATH_INFO\" ] == \"/suma\" : params = environ [ \"QUERY_STRING\" ] . split ( \"&\" ) suma = 0 for par in params : suma = suma + int ( par . split ( \"=\" )[ 1 ]) respuesta = \"<p>La suma es %d </p>\" % suma else : respuesta = \"<p><trong>P\u00e1gina incorrecta</strong></p>\" start_response ( '200 OK' , [( 'Content-Type' , 'text/html; charset=utf-8' )]) return [ respuesta . encode ()] if __name__ == '__main__' : from wsgiref.simple_server import make_server srv = make_server ( 'localhost' , 8080 , application ) srv . serve_forever () C\u00f3digo ejemplo de esta unidad","title":"2.4. Introducci\u00f3n a la programaci\u00f3n web con python"},{"location":"2_4_intro_web_py.html#introduccion-a-la-programacion-web-con-python","text":"Aunque de forma general se utilizan distintos framework (por ejemplo Flask) para el desarrollo de aplicaciones web con Python. En esta unidad voy a introducir los conceptos necesarios para crear una p\u00e1gina web desarrollada con python sin utilizar ning\u00fan framework. Para ello es necesario conocer el concepto de WSGI (Web Server Gateway Interface), que es una especificaci\u00f3n de una interface simple y universal entre los servidores web y las aplicaciones web o frameworks desarrolladas con python.","title":"Introducci\u00f3n a la programaci\u00f3n web con python"},{"location":"2_4_intro_web_py.html#creacion-de-la-aplicacion-wsgi","text":"Todas las peticiones que hagamos a nuestro servidor estar\u00e1n manejadas por la aplicaci\u00f3n WSGI, que ser\u00e1 un \u00fanico fichero. Esta aplicaci\u00f3n ser\u00e1 la responsable de manejar las peticiones, y de devolver la respuesta adecuada seg\u00fan la URI solicitada. En esta aplicaci\u00f3n tendremos que definir una funci\u00f3n, que act\u00fae con cada petici\u00f3n del usuario. Esta funci\u00f3n, deber\u00e1 ser una funci\u00f3n WSGI aplicaci\u00f3n v\u00e1lida. Esto significa que: Deber\u00e1 llamarse application. Deber\u00e1 recibir dos par\u00e1metros: environ, del m\u00f3dulo os, que provee un diccionario de las peticiones HTTP est\u00e1ndar y otras variables de entorno, y la funci\u00f3n start_response, de WSGI, encargada de entregar la respuesta HTTP al usuario. Veamos el primer ejemplo wsgi1.py: wsgi1.py # -*- coding: utf-8 -*- def application ( environ , start_response ): # Guardo la salida que devolver\u00e9 como respuesta respuesta = \"<p>P\u00e1gina web construida con <strong>Python!!!</strong></p>\" # Se genera una respuesta al navegador start_response ( '200 OK' , [( 'Content-Type' , 'text/html; charset=utf-8' )]) return [ respuesta . encode ()] if __name__ == '__main__' : from wsgiref.simple_server import make_server srv = make_server ( 'localhost' , 8080 , application ) srv . serve_forever () Para ejecutar este programa ejecutamos: $ python wsgi1.py Se crear\u00e1 un servidor web que responder\u00e1 en localhost en el puerto 8080.","title":"Creaci\u00f3n de la aplicaci\u00f3n WSGI"},{"location":"2_4_intro_web_py.html#creando-una-aplicacion-web-un-poco-mas-compleja","text":"El controlador que hemos hecho anteriormente no tiene en cuenta la URL con la que hemos accedido al servidor y siempre va a generar la misma respuesta. Utilizando la informaci\u00f3n sobre la petici\u00f3n que tenemos guardada en el diccionario environ podemos construir diferentes respuestas seg\u00fan la petici\u00f3n, por ejemplo teniendo en cuenta la URL de acceso. El diccionario environ que se recibe con cada pedido HTTP, contiene las variables est\u00e1ndar de la especificaci\u00f3n CGI, entre ellas: REQUEST_METHOD: m\u00e9todo \u201cGET\u201d, \u201cPOST\u201d, \u2026 SCRIPT_NAME: la parte inicial de la \u201cruta\u201d, que corresponde a la aplicaci\u00f3n PATH_INFO: la segunda parte de la \u201cruta\u201d, determina la \u201cubicaci\u00f3n\u201d virtual dentro de la aplicaci\u00f3n. QUERY_STRING: la porci\u00f3n de la URL que sigue al \u201c?\u201d, si existe CONTENT_TYPE, CONTENT_LENGTH de la petici\u00f3n HTTP SERVER_NAME, SERVER_PORT, que combinadas con SCRIPT_NAME y PATH_INFO dan la URL SERVER_PROTOCOL: la versi\u00f3n del protocolo (\u201cHTTP/1.0\u201d or \u201cHTTP/1.1\u201d) De esta forma podemos hacer un controlador (fichero wsgi2.py) de la siguiente manera, para comprobar la URL de acceso: wsgi2.py #-*- coding: utf-8 -*- def application ( environ , start_response ): if environ [ \"PATH_INFO\" ] == \"/\" : respuesta = \"<p>P\u00e1gina inicial</p>\" elif environ [ \"PATH_INFO\" ] == \"/hola\" : respuesta = \"<p>Bienvenidos a mi p\u00e1gina web</p>\" else : respuesta = \"<p><trong>P\u00e1gina incorrecta</strong></p>\" start_response ( '200 OK' , [( 'Content-Type' , 'text/html; charset=utf-8' )]) return [ respuesta . encode ()] if __name__ == '__main__' : from wsgiref.simple_server import make_server srv = make_server ( 'localhost' , 8080 , application ) srv . serve_forever () En este \u00faltimo ejemplo (fichero wsgi3.py) vamos a ver c\u00f3mo podemos trabajar con par\u00e1metros enviados por el m\u00e9todo GET: wsgi3.py # -*- coding: utf-8 -*- def application ( environ , start_response ): if environ [ \"PATH_INFO\" ] == \"/\" : respuesta = \"<p>P\u00e1gina inicial</p>\" elif environ [ \"PATH_INFO\" ] == \"/suma\" : params = environ [ \"QUERY_STRING\" ] . split ( \"&\" ) suma = 0 for par in params : suma = suma + int ( par . split ( \"=\" )[ 1 ]) respuesta = \"<p>La suma es %d </p>\" % suma else : respuesta = \"<p><trong>P\u00e1gina incorrecta</strong></p>\" start_response ( '200 OK' , [( 'Content-Type' , 'text/html; charset=utf-8' )]) return [ respuesta . encode ()] if __name__ == '__main__' : from wsgiref.simple_server import make_server srv = make_server ( 'localhost' , 8080 , application ) srv . serve_forever () C\u00f3digo ejemplo de esta unidad","title":"Creando una aplicaci\u00f3n web un \u201cpoco m\u00e1s compleja\u201d"},{"location":"3_1_intro.html","text":"Introducci\u00f3n a flask \u00b6 Presentaci\u00f3n de la Unidad Flask es un \u201cmicro\u201d framework escrito en Python y concebido para facilitar el desarrollo de aplicaciones Web bajo el patr\u00f3n MVC. \u00bfQu\u00e9 es un framework? \u00b6 Podemos definir framework como un esquema (un esqueleto, un patr\u00f3n) para el desarrollo y/o la implementaci\u00f3n de una aplicaci\u00f3n. En general los framework est\u00e1n asociado a lenguajes de programaci\u00f3n (Ruby on Rails (Ruby), Symphony (PHP),\u2026). Las ventajas tiene utilizar un \u2018framework\u2019 pueden ser: El programador no necesita plantearse una estructura global de la aplicaci\u00f3n, sino que el framework le proporciona un esqueleto que hay que \u201crellenar\u201d. Facilita la colaboraci\u00f3n. Cualquiera que haya tenido que \u201cpelearse\u201d con el c\u00f3digo fuente de otro programador sabr\u00e1 lo dif\u00edcil que es entenderlo y modificarlo; por tanto, todo lo que sea definir y estandarizar va a ahorrar tiempo y trabajo a los desarrollos colaborativos. Es m\u00e1s f\u00e1cil encontrar herramientas (utilidades, librer\u00edas) adaptadas al framework concreto para facilitar el desarrollo. Despu\u00e9s de estudiar la unidad: Introducci\u00f3n a la programaci\u00f3n web con python llegamos a la conclusi\u00f3n de que es necesario de utilizar un framework para ayudarnos a gestionar las peticiones y generar las respuestas correspondientes. Si utilizamos python como lenguaje de programaci\u00f3n web tenemos a nuestra disposici\u00f3n un conjunto de framework: Web Frameworks for Python. \u00bfPor qu\u00e9 usar flask? \u00b6 Flask es un \u201cmicro\u201d framework: se enfoca en proporcionar lo m\u00ednimo necesario para que puedas poner a funcionar una aplicaci\u00f3n b\u00e1sica en cuesti\u00f3n de minutos. Se necesitamos m\u00e1s funcionalidades podemos extenderlo con las Flask extensions. Incluye un servidor web de desarrollo para que puedas probar tus aplicaciones sin tener que instalar un servidor web. Tambi\u00e9n trae un depurador y soporte integrado para pruebas unitarias. Es compatible con python3, por lo tanto podemos usar la codificaci\u00f3n de caracteres unicode, y 100% compatible con el est\u00e1ndar WSGI. Buen manejo de rutas: Con el uso de un decorador python podemos hacer que nuestra aplicaci\u00f3n con URL simples y limpias. Flask soporta el uso de cookies seguras y el uso de sesiones. Flask se apoya en el motor de plantillas Jinja2, que nos permite de forma sencilla renderizar vistas y respuestas. Flask no tiene ORMs, wrappers o configuraciones complejas, eso lo convierte en un candidato ideal para aplicaciones \u00e1giles o que no necesiten manejar ninguna dependencia. Si necesitas trabajar con base de datos s\u00f3lo tenemos que utilizar una extensi\u00f3n. Este framework resulta ideal para construir servicios web (como APIs REST) o aplicaciones de contenido est\u00e1tico. Flask es Open Source y est\u00e1 amparado bajo una licencia BSD. Puedes ver el c\u00f3digo en Github , la documentaci\u00f3n es muy completa y te puedes suscribir a su lista de correos para mantenerte al d\u00eda de las actualizaciones. Extensiones flask \u00b6 Ya hemos visto la lista de extensiones que nos permite ampliar la funcionalidad de Flask, en este curso vamos a utilizar las siguientes: Flask-Script: La extensi\u00f3n flask-script nos proporciona la posibilidad de gestionar nuestra aplicaci\u00f3n flask desde una comando (Interfaz de l\u00ednea de comando). Flask-Bootstrap: si queremos trabajar con plantillas que utilicen como hoja de estilos y javascript el framework bootstrap podemos ulizar la extansi\u00f3n Flask-Bootstrap. Flask-WTF: Flask-WTF es una extensi\u00f3n de Flask que nos permite trabajar con la librer\u00eda WTForm de python, que nos facilita la generaci\u00f3n y validaci\u00f3n de formularios HTML. Flask-Sqlalchemy: Usaremos la extensi\u00f3n Flask-SQLAlchemy que nos provee un wrapper para el proyecto SQLAlchemy, el cual es un Object Relational Mapper o ORM. Flask-Login: Flask-Login es una librer\u00eda que nos proporciona la posibilidad de gestionar las sesiones de nuestros usuarios","title":"3.1. Introducci\u00f3n a flask"},{"location":"3_1_intro.html#introduccion-a-flask","text":"Presentaci\u00f3n de la Unidad Flask es un \u201cmicro\u201d framework escrito en Python y concebido para facilitar el desarrollo de aplicaciones Web bajo el patr\u00f3n MVC.","title":"Introducci\u00f3n a flask"},{"location":"3_1_intro.html#que-es-un-framework","text":"Podemos definir framework como un esquema (un esqueleto, un patr\u00f3n) para el desarrollo y/o la implementaci\u00f3n de una aplicaci\u00f3n. En general los framework est\u00e1n asociado a lenguajes de programaci\u00f3n (Ruby on Rails (Ruby), Symphony (PHP),\u2026). Las ventajas tiene utilizar un \u2018framework\u2019 pueden ser: El programador no necesita plantearse una estructura global de la aplicaci\u00f3n, sino que el framework le proporciona un esqueleto que hay que \u201crellenar\u201d. Facilita la colaboraci\u00f3n. Cualquiera que haya tenido que \u201cpelearse\u201d con el c\u00f3digo fuente de otro programador sabr\u00e1 lo dif\u00edcil que es entenderlo y modificarlo; por tanto, todo lo que sea definir y estandarizar va a ahorrar tiempo y trabajo a los desarrollos colaborativos. Es m\u00e1s f\u00e1cil encontrar herramientas (utilidades, librer\u00edas) adaptadas al framework concreto para facilitar el desarrollo. Despu\u00e9s de estudiar la unidad: Introducci\u00f3n a la programaci\u00f3n web con python llegamos a la conclusi\u00f3n de que es necesario de utilizar un framework para ayudarnos a gestionar las peticiones y generar las respuestas correspondientes. Si utilizamos python como lenguaje de programaci\u00f3n web tenemos a nuestra disposici\u00f3n un conjunto de framework: Web Frameworks for Python.","title":"\u00bfQu\u00e9 es un framework?"},{"location":"3_1_intro.html#por-que-usar-flask","text":"Flask es un \u201cmicro\u201d framework: se enfoca en proporcionar lo m\u00ednimo necesario para que puedas poner a funcionar una aplicaci\u00f3n b\u00e1sica en cuesti\u00f3n de minutos. Se necesitamos m\u00e1s funcionalidades podemos extenderlo con las Flask extensions. Incluye un servidor web de desarrollo para que puedas probar tus aplicaciones sin tener que instalar un servidor web. Tambi\u00e9n trae un depurador y soporte integrado para pruebas unitarias. Es compatible con python3, por lo tanto podemos usar la codificaci\u00f3n de caracteres unicode, y 100% compatible con el est\u00e1ndar WSGI. Buen manejo de rutas: Con el uso de un decorador python podemos hacer que nuestra aplicaci\u00f3n con URL simples y limpias. Flask soporta el uso de cookies seguras y el uso de sesiones. Flask se apoya en el motor de plantillas Jinja2, que nos permite de forma sencilla renderizar vistas y respuestas. Flask no tiene ORMs, wrappers o configuraciones complejas, eso lo convierte en un candidato ideal para aplicaciones \u00e1giles o que no necesiten manejar ninguna dependencia. Si necesitas trabajar con base de datos s\u00f3lo tenemos que utilizar una extensi\u00f3n. Este framework resulta ideal para construir servicios web (como APIs REST) o aplicaciones de contenido est\u00e1tico. Flask es Open Source y est\u00e1 amparado bajo una licencia BSD. Puedes ver el c\u00f3digo en Github , la documentaci\u00f3n es muy completa y te puedes suscribir a su lista de correos para mantenerte al d\u00eda de las actualizaciones.","title":"\u00bfPor qu\u00e9 usar flask?"},{"location":"3_1_intro.html#extensiones-flask","text":"Ya hemos visto la lista de extensiones que nos permite ampliar la funcionalidad de Flask, en este curso vamos a utilizar las siguientes: Flask-Script: La extensi\u00f3n flask-script nos proporciona la posibilidad de gestionar nuestra aplicaci\u00f3n flask desde una comando (Interfaz de l\u00ednea de comando). Flask-Bootstrap: si queremos trabajar con plantillas que utilicen como hoja de estilos y javascript el framework bootstrap podemos ulizar la extansi\u00f3n Flask-Bootstrap. Flask-WTF: Flask-WTF es una extensi\u00f3n de Flask que nos permite trabajar con la librer\u00eda WTForm de python, que nos facilita la generaci\u00f3n y validaci\u00f3n de formularios HTML. Flask-Sqlalchemy: Usaremos la extensi\u00f3n Flask-SQLAlchemy que nos provee un wrapper para el proyecto SQLAlchemy, el cual es un Object Relational Mapper o ORM. Flask-Login: Flask-Login es una librer\u00eda que nos proporciona la posibilidad de gestionar las sesiones de nuestros usuarios","title":"Extensiones flask"},{"location":"3_2_instalacion_flask.html","text":"Instalaci\u00f3n flask \u00b6 Vamos a realizar la instalaci\u00f3n de Flask utilizando la herramienta pip en un entorno virtual creado con virtualenv. La instalaci\u00f3n de Flask depende de dos paquetes: Werkzeug , una librer\u00eda WSGI para Python y jinja2 como motor de plantillas. Creando el entorno virtual \u00b6 Como Flask es compatible con python3 vamos a crear un entorno virtual compatible con la versi\u00f3n 3 del interprete python. Para ello nos aseguremos que tenemos la utilidad instalada: # apt-get install python-virtualenv Y creamos el entorno virtual: $ virtualenv -p /usr/bin/python3 flask Para activar nuestro entorno virtual: $ source flask/bin/activate (flask)$ Y a continuaci\u00f3n instalamos Flask: (flask)$ pip install Flask Si nos aparece el siguiente aviso durante la instalaci\u00f3n: WARNING: The C extension could not be compiled, speedups are not enabled. Failure information, if any, is above. Retrying the build without the C extension now. La instalaci\u00f3n se realiza bien, pero no se habilita el aumento de rendimiento de jinja2. Puedes volver a realizar la instalaci\u00f3n despu\u00e9s de instalar el siguiente paquete: apt-get install python3-dev \u00b6 Al finalizar podemos comprobar los paquetes python instalados: (flask)$ pip freeze click==8.1.3 Flask==2.2.2 itsdangerous==2.1.2 Jinja2==3.1.2 MarkupSafe==2.1.1 Werkzeug==2.2.2 Podemos guardar las dependencias en un fichero requirements.txt: # pip freeze > requirements.txt La utilizaci\u00f3n del fichero \u02cbrequirements.txt\u02cb, donde vamos a ir guardando los paquetes python (y sus versiones) de nuestra instalaci\u00f3n, nos va a posibilitar posteriormente poder crear otro entrono virtual con los mismos paquetes: # pip install -r requirements.txt Y finalmente comprobamos la versi\u00f3n de flask que tenemos instalada: (flask)$ flask --version Python 3.9.7 Flask 2.2.2 Werkzeug 2.2.2","title":"3.2. Instalaci\u00f3n de flask"},{"location":"3_2_instalacion_flask.html#instalacion-flask","text":"Vamos a realizar la instalaci\u00f3n de Flask utilizando la herramienta pip en un entorno virtual creado con virtualenv. La instalaci\u00f3n de Flask depende de dos paquetes: Werkzeug , una librer\u00eda WSGI para Python y jinja2 como motor de plantillas.","title":"Instalaci\u00f3n  flask"},{"location":"3_2_instalacion_flask.html#creando-el-entorno-virtual","text":"Como Flask es compatible con python3 vamos a crear un entorno virtual compatible con la versi\u00f3n 3 del interprete python. Para ello nos aseguremos que tenemos la utilidad instalada: # apt-get install python-virtualenv Y creamos el entorno virtual: $ virtualenv -p /usr/bin/python3 flask Para activar nuestro entorno virtual: $ source flask/bin/activate (flask)$ Y a continuaci\u00f3n instalamos Flask: (flask)$ pip install Flask Si nos aparece el siguiente aviso durante la instalaci\u00f3n: WARNING: The C extension could not be compiled, speedups are not enabled. Failure information, if any, is above. Retrying the build without the C extension now. La instalaci\u00f3n se realiza bien, pero no se habilita el aumento de rendimiento de jinja2. Puedes volver a realizar la instalaci\u00f3n despu\u00e9s de instalar el siguiente paquete:","title":"Creando el entorno virtual"},{"location":"3_3_corriendo_sencillo.html","text":"Corriendo una aplicaci\u00f3n sencilla \u00b6 Escribimos nuestra primera aplicaci\u00f3n flask, en un fichero app.py: from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello, World!' if __name__ == '__main__': app.run() 1. El objeto app de la clase Flask es nuestra aplicaci\u00f3n WSGI, que nos permitir\u00e1 posteriormente desplegar nuestra aplicaci\u00f3n en un servidor Web. Se le pasa como par\u00e1metro el m\u00f3dulo actual ( name ). 2. El decorador router nos permite filtrar la petici\u00f3n HTTP recibida, de tal forma que si la petici\u00f3n se realiza a la URL / se ejecutar\u00e1 la funci\u00f3n vista hello_word. 3. La funci\u00f3n vista que se ejecuta devuelve una respuesta HTTP. En este caso devuelve una cadena de caracteres que se ser\u00e1 los datos de la respuesta. 4. Finalmente si ejecutamos este m\u00f3dulo se ejecuta el m\u00e9todo run que ejecuta un servidor web para que podamos probar la aplicaci\u00f3n. De esta forma podemos ejecutar nuestra primera aplicaci\u00f3n: $ python3 app.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) Y podemos acceder a la URL http://127.0.0.1:5000/ desde nuestro navegador y ver el resultado. O podemos ejecutar: $ curl http://127.0.0.1:5000 Hello, World! Configuraci\u00f3n del servidor web de desarrollo \u00b6 Podemos cambiar la direcci\u00f3n y el puerto desde donde nuestro servidor web va a responder. Por ejemplo si queremos acceder a nuestra aplicaci\u00f3n desde cualquier direcci\u00f3n en el puerto 8080: ... app.run('0.0.0.0',8080) $ python3 app.py * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit) Modo \u201cdebug\u201d \u00b6 Si activamos este modo durante el proceso de desarrollo de nuestra aplicaci\u00f3n tendremos a nuestra disposici\u00f3n una herramienta de depuraci\u00f3n que nos permitir\u00e1 estudiar los posibles errores cometidos, adem\u00e1s se activa el modo \u201creload\u201d que inicia autom\u00e1ticamente el servidor de desarrollo cuando sea necesario. Para activar este modo: ... app.run(debug=True) $ python3 app.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 106-669-497 El Debugger PIN lo utilizaremos para utilizar la herramienta de depuraci\u00f3n. C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"3.3. Corriendo una aplicaci\u00f3n sencilla"},{"location":"3_3_corriendo_sencillo.html#corriendo-una-aplicacion-sencilla","text":"Escribimos nuestra primera aplicaci\u00f3n flask, en un fichero app.py: from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello, World!' if __name__ == '__main__': app.run() 1. El objeto app de la clase Flask es nuestra aplicaci\u00f3n WSGI, que nos permitir\u00e1 posteriormente desplegar nuestra aplicaci\u00f3n en un servidor Web. Se le pasa como par\u00e1metro el m\u00f3dulo actual ( name ). 2. El decorador router nos permite filtrar la petici\u00f3n HTTP recibida, de tal forma que si la petici\u00f3n se realiza a la URL / se ejecutar\u00e1 la funci\u00f3n vista hello_word. 3. La funci\u00f3n vista que se ejecuta devuelve una respuesta HTTP. En este caso devuelve una cadena de caracteres que se ser\u00e1 los datos de la respuesta. 4. Finalmente si ejecutamos este m\u00f3dulo se ejecuta el m\u00e9todo run que ejecuta un servidor web para que podamos probar la aplicaci\u00f3n. De esta forma podemos ejecutar nuestra primera aplicaci\u00f3n: $ python3 app.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) Y podemos acceder a la URL http://127.0.0.1:5000/ desde nuestro navegador y ver el resultado. O podemos ejecutar: $ curl http://127.0.0.1:5000 Hello, World!","title":"Corriendo una aplicaci\u00f3n sencilla"},{"location":"3_3_corriendo_sencillo.html#configuracion-del-servidor-web-de-desarrollo","text":"Podemos cambiar la direcci\u00f3n y el puerto desde donde nuestro servidor web va a responder. Por ejemplo si queremos acceder a nuestra aplicaci\u00f3n desde cualquier direcci\u00f3n en el puerto 8080: ... app.run('0.0.0.0',8080) $ python3 app.py * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit)","title":"Configuraci\u00f3n del servidor web de desarrollo"},{"location":"3_3_corriendo_sencillo.html#modo-debug","text":"Si activamos este modo durante el proceso de desarrollo de nuestra aplicaci\u00f3n tendremos a nuestra disposici\u00f3n una herramienta de depuraci\u00f3n que nos permitir\u00e1 estudiar los posibles errores cometidos, adem\u00e1s se activa el modo \u201creload\u201d que inicia autom\u00e1ticamente el servidor de desarrollo cuando sea necesario. Para activar este modo: ... app.run(debug=True) $ python3 app.py * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 106-669-497 El Debugger PIN lo utilizaremos para utilizar la herramienta de depuraci\u00f3n.","title":"Modo \u201cdebug\u201d"},{"location":"3_3_corriendo_sencillo.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"3_4_organizando_codigo.html","text":"Estructura de nuestra aplicaci\u00f3n \u00b6 Vamos a organizar nuestra aplicaci\u00f3n web en un paquete con la siguiente estrucutra de directorios: manage.py requirements.txt aplicacion app.py __init__.py + manage.py: Ser\u00e1 el script que utilizaremos para gestionar la aplicaci\u00f3n . + requirements.txt: Fichero con los m\u00f3dulos necesarios para nuestra aplicaci\u00f3n funcione. + aplicacion: Paquete python (hemos creado el fichero init .py) donde vamos a guardar los ficheros de nuestra aplicaci\u00f3n, por ahora guardamos el m\u00f3dulo principal app.py. Contenido manage.py \u00b6 El contenido del fichero manage.py ser\u00e1 el siguiente: from aplicacion.app import app if __name__ == '__main__': app.run(debug=True) Contenido app.py \u00b6 El contenido del fichero app.py ser\u00e1 el siguiente: from flask import Flask from flask.cli import FlaskGroup app = Flask(__name__) @app.route('/') def inicio(): return 'P\u00e1gina principal' Como puedes observar dejamos todo el trabajo a app.py, donde controlaremos las rutas y los diferentes elementos, utilizando manage.py s\u00f3lo como punto de entrada de la aplicaci\u00f3n. C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"3.4. Organizando el C\u00f3digo"},{"location":"3_4_organizando_codigo.html#estructura-de-nuestra-aplicacion","text":"Vamos a organizar nuestra aplicaci\u00f3n web en un paquete con la siguiente estrucutra de directorios: manage.py requirements.txt aplicacion app.py __init__.py + manage.py: Ser\u00e1 el script que utilizaremos para gestionar la aplicaci\u00f3n . + requirements.txt: Fichero con los m\u00f3dulos necesarios para nuestra aplicaci\u00f3n funcione. + aplicacion: Paquete python (hemos creado el fichero init .py) donde vamos a guardar los ficheros de nuestra aplicaci\u00f3n, por ahora guardamos el m\u00f3dulo principal app.py.","title":"Estructura de nuestra aplicaci\u00f3n"},{"location":"3_4_organizando_codigo.html#contenido-managepy","text":"El contenido del fichero manage.py ser\u00e1 el siguiente: from aplicacion.app import app if __name__ == '__main__': app.run(debug=True)","title":"Contenido manage.py"},{"location":"3_4_organizando_codigo.html#contenido-apppy","text":"El contenido del fichero app.py ser\u00e1 el siguiente: from flask import Flask from flask.cli import FlaskGroup app = Flask(__name__) @app.route('/') def inicio(): return 'P\u00e1gina principal' Como puedes observar dejamos todo el trabajo a app.py, donde controlaremos las rutas y los diferentes elementos, utilizando manage.py s\u00f3lo como punto de entrada de la aplicaci\u00f3n. C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"Contenido app.py"},{"location":"4_1_enrutamiento_rutas.html","text":"Enrutamiento: rutas \u00b6 El objeto Flask app nos proporciona un decorador router que es capaz de filtrar la funci\u00f3n vista que se va ejecutar analizando la petici\u00f3n HTTP, fundamentalmente por la ruta y el m\u00e9todo que se hace la petici\u00f3n. Trabajando con rutas \u00b6 Veamos un ejemplo: ... @app.route('/') def inicio(): return 'P\u00e1gina principal' @app.route('/articulos/') def articulos(): return 'Lista de art\u00edculos' @app.route('/acercade') def acercade(): return 'P\u00e1gina acerca de...' En este caso se comprueba la ruta de la petici\u00f3n HTTP, y cuando coincide con alguna indicada en las rutas se ejecuta la funci\u00f3n correspondiente devolviendo una respuesta HTTP. curl http://localhost:5000 P\u00e1gina principal Si declaramos rutas terminando en / son consideradas como un directorio de un sistema de fichero, en este caso si se accede a la ruta sin la barra final se producir\u00e1 una redirecci\u00f3n a la ruta correcta. curl http://localhost:5000/articulos/ Lista de art\u00edculos curl http://localhost:5000/articulos <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>Redirecting...</title> <h1>Redirecting...</h1> <p>You should be redirected automatically to target URL: <a href=\"http://localhost:5000/articulos/\">http://localhost:5000/articulos/</a>. If not click the link. Si declaramos la rutas sin / final, se consideran un fichero del sistema de fichero, si accedemos a la ruta con el / nos devolver\u00e1 una respuesta con c\u00f3digo 404. curl http://localhost:5000/acercade P\u00e1gina acerca de... curl http://localhost:5000/acercade/ <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>404 Not Found</title> <h1>Not Found</h1> <p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p> Si la ruta de la petici\u00f3n HTTP no corresponde con ninguna que hayamos indicado se devolver\u00e1 una respuesta con c\u00f3digo de estado 404 indicando que no se ha encontrado el recurso. Rutas din\u00e1micas \u00b6 Podemos gestionar rutas variables, es decir que correspondan a un determinado patr\u00f3n o expresi\u00f3n regular, por ejemplo: @app.route(\"/articulos/<int:id>\") def mostrar_ariculo(id): return 'Vamos a mostrar el art\u00edculo con id:{id}' curl http://localhost:5000/articulos/6 Vamos a mostrar el art\u00edculo con id:6 Otro ejemplo: @app.route(\"/hello/\") @app.route(\"/hello/<string:nombre>\") @app.route(\"/hello/<string:nombre>/<int:edad>\") def hola(nombre=None,edad=None): if nombre and edad: return 'Hola, {nombre} tienes {edad} a\u00f1os.' elif nombre: return 'Hola, {nombre}'.format(nombre) else: return 'Hola mundo' curl http://localhost:5000/hello/ Hola mundo curl http://localhost:5000/hello/pepe Hola, pepe curl http://localhost:5000/hello/pepe/16 Hola, pepe tienes 16 a\u00f1os. La parte din\u00e1mica de la ruta la podemos obtener como variable que recibe la funci\u00f3n correspondiente. En el segundo ejemplo, adem\u00e1s observamos que varias rutas pueden ejecutar una misma funci\u00f3n. Aunque no es obligatorio podemos especificar el tipo de la variable capturada: string: Acepta cualquier texto sin barras (por defecto) int: Acepta enteros float: Acepta valores reales path: Acepta cadena de caracteres con barras Construcci\u00f3n de rutas \u00b6 Podemos importar la funci\u00f3n url_for que nos permite construir rutas a partir del nombre de la funci\u00f3n asociada: python3 manage shell In [1]: from flask import url_for In [2]: url_for('articulos') Out[2]: '/articulos/' In [3]: url_for('hola',nombre=\"pepe\") Out[3]: '/hello/pepe' In [4]: url_for('hola',nombre=\"pepe\",edad=40) Out[4]: '/hello/pepe/40' C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"4.1 Enrutamiento: Rutas"},{"location":"4_1_enrutamiento_rutas.html#enrutamiento-rutas","text":"El objeto Flask app nos proporciona un decorador router que es capaz de filtrar la funci\u00f3n vista que se va ejecutar analizando la petici\u00f3n HTTP, fundamentalmente por la ruta y el m\u00e9todo que se hace la petici\u00f3n.","title":"Enrutamiento: rutas"},{"location":"4_1_enrutamiento_rutas.html#trabajando-con-rutas","text":"Veamos un ejemplo: ... @app.route('/') def inicio(): return 'P\u00e1gina principal' @app.route('/articulos/') def articulos(): return 'Lista de art\u00edculos' @app.route('/acercade') def acercade(): return 'P\u00e1gina acerca de...' En este caso se comprueba la ruta de la petici\u00f3n HTTP, y cuando coincide con alguna indicada en las rutas se ejecuta la funci\u00f3n correspondiente devolviendo una respuesta HTTP. curl http://localhost:5000 P\u00e1gina principal Si declaramos rutas terminando en / son consideradas como un directorio de un sistema de fichero, en este caso si se accede a la ruta sin la barra final se producir\u00e1 una redirecci\u00f3n a la ruta correcta. curl http://localhost:5000/articulos/ Lista de art\u00edculos curl http://localhost:5000/articulos <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>Redirecting...</title> <h1>Redirecting...</h1> <p>You should be redirected automatically to target URL: <a href=\"http://localhost:5000/articulos/\">http://localhost:5000/articulos/</a>. If not click the link. Si declaramos la rutas sin / final, se consideran un fichero del sistema de fichero, si accedemos a la ruta con el / nos devolver\u00e1 una respuesta con c\u00f3digo 404. curl http://localhost:5000/acercade P\u00e1gina acerca de... curl http://localhost:5000/acercade/ <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>404 Not Found</title> <h1>Not Found</h1> <p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p> Si la ruta de la petici\u00f3n HTTP no corresponde con ninguna que hayamos indicado se devolver\u00e1 una respuesta con c\u00f3digo de estado 404 indicando que no se ha encontrado el recurso.","title":"Trabajando con rutas"},{"location":"4_1_enrutamiento_rutas.html#rutas-dinamicas","text":"Podemos gestionar rutas variables, es decir que correspondan a un determinado patr\u00f3n o expresi\u00f3n regular, por ejemplo: @app.route(\"/articulos/<int:id>\") def mostrar_ariculo(id): return 'Vamos a mostrar el art\u00edculo con id:{id}' curl http://localhost:5000/articulos/6 Vamos a mostrar el art\u00edculo con id:6 Otro ejemplo: @app.route(\"/hello/\") @app.route(\"/hello/<string:nombre>\") @app.route(\"/hello/<string:nombre>/<int:edad>\") def hola(nombre=None,edad=None): if nombre and edad: return 'Hola, {nombre} tienes {edad} a\u00f1os.' elif nombre: return 'Hola, {nombre}'.format(nombre) else: return 'Hola mundo' curl http://localhost:5000/hello/ Hola mundo curl http://localhost:5000/hello/pepe Hola, pepe curl http://localhost:5000/hello/pepe/16 Hola, pepe tienes 16 a\u00f1os. La parte din\u00e1mica de la ruta la podemos obtener como variable que recibe la funci\u00f3n correspondiente. En el segundo ejemplo, adem\u00e1s observamos que varias rutas pueden ejecutar una misma funci\u00f3n. Aunque no es obligatorio podemos especificar el tipo de la variable capturada: string: Acepta cualquier texto sin barras (por defecto) int: Acepta enteros float: Acepta valores reales path: Acepta cadena de caracteres con barras","title":"Rutas din\u00e1micas"},{"location":"4_1_enrutamiento_rutas.html#construccion-de-rutas","text":"Podemos importar la funci\u00f3n url_for que nos permite construir rutas a partir del nombre de la funci\u00f3n asociada: python3 manage shell In [1]: from flask import url_for In [2]: url_for('articulos') Out[2]: '/articulos/' In [3]: url_for('hola',nombre=\"pepe\") Out[3]: '/hello/pepe' In [4]: url_for('hola',nombre=\"pepe\",edad=40) Out[4]: '/hello/pepe/40' C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"Construcci\u00f3n de rutas"},{"location":"4_2_enrutamiento_metodos.html","text":"Enrutamiento: M\u00e9todos \u00b6 Para acceder a las distintas URLs podemos utilizar varios m\u00e9todos en nuestra petici\u00f3n HTTP. En nuestros ejemplos vamos a trabajar con el m\u00e9todo GET y POST, que son los m\u00e9todos que normalmente podemos utilizar desde un navegador web. GET: Se realiza una petici\u00f3n para obtener un recurso del servidor web. Es el m\u00e9todo m\u00e1s utilizado. POST: Aunque con el m\u00e9todo GET tambi\u00e9n podemos mandar informaci\u00f3n al servidor (por medio de par\u00e1metros escritas en la URL), utilizamos el m\u00e9todo POST para enviar informaci\u00f3n a una determinada URL. Normalmente utilizamos los formularios HTML para enviar informaci\u00f3n al servidor por medio del m\u00e9todo POST: Por defecto las rutas indicadas en la funciones route s\u00f3lo son accesibles utilizando el m\u00e9todo GET. Por ejemplo: $ curl -X POST http://localhost:5000/articulos/ <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>405 Method Not Allowed</title> <h1>Method Not Allowed</h1> <p>The method is not allowed for the requested URL.</p> Si una URL recibe informaci\u00f3n por medio del m\u00e9todo POST y no queremos que se acceda a ella con un m\u00e9todo GET, se definir\u00e1 de la siguiente manera: @app.route('/articulos/new',methods=[\"POST\"]) def articulos_new(): return 'Est\u00e1 URL recibe informaci\u00f3n de un formulario con el m\u00e9todo POST' Y por lo tanto: curl http://localhost:5000/articulos/new <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>405 Method Not Allowed</title> <h1>Method Not Allowed</h1> <p>The method is not allowed for the requested URL.</p> curl -X POST http://localhost:5000/articulos/new Est\u00e1 URL recibe informaci\u00f3n de un formulario con el m\u00e9todo POST Tambi\u00e9n en muchas ocasiones es deseable acceder a una URL con los dos m\u00e9todos, de tal manera que haremos una cosa cuando acedemos con GET y haremos otra cuando se acceda con POST. Ejemplo: #A\u00f1adimos en el import from flask import Flask, request ... @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': return 'Hemos accedido con POST' else: return 'Hemos accedido con GET' Y si accedemos: curl http://localhost:5000/login Hemos accedido con GET curl -X POST http://localhost:5000/login Hemos accedido con POST En este ejemplo hemos utilizado el objeto request que estudiaremos en la siguiente unidad. C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"4.2 Enrutamiento: M\u00e9todos"},{"location":"4_2_enrutamiento_metodos.html#enrutamiento-metodos","text":"Para acceder a las distintas URLs podemos utilizar varios m\u00e9todos en nuestra petici\u00f3n HTTP. En nuestros ejemplos vamos a trabajar con el m\u00e9todo GET y POST, que son los m\u00e9todos que normalmente podemos utilizar desde un navegador web. GET: Se realiza una petici\u00f3n para obtener un recurso del servidor web. Es el m\u00e9todo m\u00e1s utilizado. POST: Aunque con el m\u00e9todo GET tambi\u00e9n podemos mandar informaci\u00f3n al servidor (por medio de par\u00e1metros escritas en la URL), utilizamos el m\u00e9todo POST para enviar informaci\u00f3n a una determinada URL. Normalmente utilizamos los formularios HTML para enviar informaci\u00f3n al servidor por medio del m\u00e9todo POST: Por defecto las rutas indicadas en la funciones route s\u00f3lo son accesibles utilizando el m\u00e9todo GET. Por ejemplo: $ curl -X POST http://localhost:5000/articulos/ <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>405 Method Not Allowed</title> <h1>Method Not Allowed</h1> <p>The method is not allowed for the requested URL.</p> Si una URL recibe informaci\u00f3n por medio del m\u00e9todo POST y no queremos que se acceda a ella con un m\u00e9todo GET, se definir\u00e1 de la siguiente manera: @app.route('/articulos/new',methods=[\"POST\"]) def articulos_new(): return 'Est\u00e1 URL recibe informaci\u00f3n de un formulario con el m\u00e9todo POST' Y por lo tanto: curl http://localhost:5000/articulos/new <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>405 Method Not Allowed</title> <h1>Method Not Allowed</h1> <p>The method is not allowed for the requested URL.</p> curl -X POST http://localhost:5000/articulos/new Est\u00e1 URL recibe informaci\u00f3n de un formulario con el m\u00e9todo POST Tambi\u00e9n en muchas ocasiones es deseable acceder a una URL con los dos m\u00e9todos, de tal manera que haremos una cosa cuando acedemos con GET y haremos otra cuando se acceda con POST. Ejemplo: #A\u00f1adimos en el import from flask import Flask, request ... @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': return 'Hemos accedido con POST' else: return 'Hemos accedido con GET' Y si accedemos: curl http://localhost:5000/login Hemos accedido con GET curl -X POST http://localhost:5000/login Hemos accedido con POST En este ejemplo hemos utilizado el objeto request que estudiaremos en la siguiente unidad. C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"Enrutamiento: M\u00e9todos"},{"location":"4_3_trabajando_peticiones.html","text":"Enrutamiento: M\u00e9todos \u00b6 Para acceder a las distintas URLs podemos utilizar varios m\u00e9todos en nuestra petici\u00f3n HTTP. En nuestros ejemplos vamos a trabajar con el m\u00e9todo GET y POST, que son los m\u00e9todos que normalmente podemos utilizar desde un navegador web. GET: Se realiza una petici\u00f3n para obtener un recurso del servidor web. Es el m\u00e9todo m\u00e1s utilizado. POST: Aunque con el m\u00e9todo GET tambi\u00e9n podemos mandar informaci\u00f3n al servidor (por medio de par\u00e1metros escritas en la URL), utilizamos el m\u00e9todo POST para enviar informaci\u00f3n a una determinada URL. Normalmente utilizamos los formularios HTML para enviar informaci\u00f3n al servidor por medio del m\u00e9todo POST: Por defecto las rutas indicadas en la funciones route s\u00f3lo son accesibles utilizando el m\u00e9todo GET. Por ejemplo: $ curl -X POST http://localhost:5000/articulos/ <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>405 Method Not Allowed</title> <h1>Method Not Allowed</h1> <p>The method is not allowed for the requested URL.</p> Si una URL recibe informaci\u00f3n por medio del m\u00e9todo POST y no queremos que se acceda a ella con un m\u00e9todo GET, se definir\u00e1 de la siguiente manera: @app.route('/articulos/new',methods=[\"POST\"]) def articulos_new(): return 'Est\u00e1 URL recibe informaci\u00f3n de un formulario con el m\u00e9todo POST' Y por lo tanto: curl http://localhost:5000/articulos/new <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>405 Method Not Allowed</title> <h1>Method Not Allowed</h1> <p>The method is not allowed for the requested URL.</p> curl -X POST http://localhost:5000/articulos/new Est\u00e1 URL recibe informaci\u00f3n de un formulario con el m\u00e9todo POST Tambi\u00e9n en muchas ocasiones es deseable acceder a una URL con los dos m\u00e9todos, de tal manera que haremos una cosa cuando acedemos con GET y haremos otra cuando se acceda con POST. Ejemplo: #A\u00f1adimos en el import from flask import Flask, request ... @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': return 'Hemos accedido con POST' else: return 'Hemos accedido con GET' Y si accedemos: curl http://localhost:5000/login Hemos accedido con GET curl -X POST http://localhost:5000/login Hemos accedido con POST En este ejemplo hemos utilizado el objeto request que estudiaremos en la siguiente unidad. C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"4.3 Trabajando con peticiones HTTP"},{"location":"4_3_trabajando_peticiones.html#enrutamiento-metodos","text":"Para acceder a las distintas URLs podemos utilizar varios m\u00e9todos en nuestra petici\u00f3n HTTP. En nuestros ejemplos vamos a trabajar con el m\u00e9todo GET y POST, que son los m\u00e9todos que normalmente podemos utilizar desde un navegador web. GET: Se realiza una petici\u00f3n para obtener un recurso del servidor web. Es el m\u00e9todo m\u00e1s utilizado. POST: Aunque con el m\u00e9todo GET tambi\u00e9n podemos mandar informaci\u00f3n al servidor (por medio de par\u00e1metros escritas en la URL), utilizamos el m\u00e9todo POST para enviar informaci\u00f3n a una determinada URL. Normalmente utilizamos los formularios HTML para enviar informaci\u00f3n al servidor por medio del m\u00e9todo POST: Por defecto las rutas indicadas en la funciones route s\u00f3lo son accesibles utilizando el m\u00e9todo GET. Por ejemplo: $ curl -X POST http://localhost:5000/articulos/ <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>405 Method Not Allowed</title> <h1>Method Not Allowed</h1> <p>The method is not allowed for the requested URL.</p> Si una URL recibe informaci\u00f3n por medio del m\u00e9todo POST y no queremos que se acceda a ella con un m\u00e9todo GET, se definir\u00e1 de la siguiente manera: @app.route('/articulos/new',methods=[\"POST\"]) def articulos_new(): return 'Est\u00e1 URL recibe informaci\u00f3n de un formulario con el m\u00e9todo POST' Y por lo tanto: curl http://localhost:5000/articulos/new <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>405 Method Not Allowed</title> <h1>Method Not Allowed</h1> <p>The method is not allowed for the requested URL.</p> curl -X POST http://localhost:5000/articulos/new Est\u00e1 URL recibe informaci\u00f3n de un formulario con el m\u00e9todo POST Tambi\u00e9n en muchas ocasiones es deseable acceder a una URL con los dos m\u00e9todos, de tal manera que haremos una cosa cuando acedemos con GET y haremos otra cuando se acceda con POST. Ejemplo: #A\u00f1adimos en el import from flask import Flask, request ... @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': return 'Hemos accedido con POST' else: return 'Hemos accedido con GET' Y si accedemos: curl http://localhost:5000/login Hemos accedido con GET curl -X POST http://localhost:5000/login Hemos accedido con POST En este ejemplo hemos utilizado el objeto request que estudiaremos en la siguiente unidad. C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"Enrutamiento: M\u00e9todos"},{"location":"4_4_gen_http.html","text":"Generando respuestas HTTP, respuestas de error y redirecciones \u00b6 El decorador router gestiona la petici\u00f3n HTTP recibida y crea un objeto reponse con la respuesta HTTP: el c\u00f3digo de estado, las cabaceras y los datos devueltos. Esta respuesta la prepara a partir de lo que devuelve la funci\u00f3n vista ejecutada con cada route. Estas funciones pueden devolver tres tipos de datos: Una cadena, o la generaci\u00f3n de una plantilla (que veremos posteriormente). Por defecto se indica un c\u00f3digo 200 y las cabeceras por defecto. Un objeto de la clase response generado con la funci\u00f3n make_repsonse, que recibe los datos devueltos, el c\u00f3digo de estado y las cabeceras. Una tupla con los mismos datos: datos, cabeceras y c\u00f3digo de respuesta. Ejemplo de respuestas \u00b6 Veamos el siguiente c\u00f3digo: from flask import Flask, request, make_response, abort, redirect, url_for ... @app.route('/string/') def return_string(): return 'Hello, world!' @app.route('/object/') def return_object(): headers = {'Content-Type': 'text/plain'} return make_response('Hello, world!', 200,headers) @app.route('/tuple/') def return_tuple(): return 'Hello, world!', 200, {'Content-Type':'text/plain'} Puedes comprobar que devuelve cada una de las rutas. Respuestas de error \u00b6 Si queremos que en cualquier momento devolver una respuesta HTTP de error podemos utilizar la funci\u00f3n abort: @app.route('/login') def login(): abort(401) # Esta l\u00ednea no se ejecuta Y lo comprobamos: curl http://localhost:5000/login <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>401 Unauthorized</title> <h1>Unauthorized</h1> <p>The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.</p> Si queremos responder de la misma manera un determinado c\u00f3digo de estado, por ejemplo queremos devolver una respuesta determinada cuando no se encuentra un recurso: @app.errorhandler(404) def page_not_found(error): return 'P\u00e1gina no encontrada...', 404 curl http://localhost:5000/PaginaNoExiste P\u00e1gina no encontrada... Redirecciones \u00b6 Si queremos realizar una redicirecci\u00f3n HTTP a otra URL utilizamos la funci\u00f3n redirect: @app.route('/') def index(): return redirect(url_for('return_string')) C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"4.4 Generando respuestas HTTP, respuestas de error y redirecciones"},{"location":"4_4_gen_http.html#generando-respuestas-http-respuestas-de-error-y-redirecciones","text":"El decorador router gestiona la petici\u00f3n HTTP recibida y crea un objeto reponse con la respuesta HTTP: el c\u00f3digo de estado, las cabaceras y los datos devueltos. Esta respuesta la prepara a partir de lo que devuelve la funci\u00f3n vista ejecutada con cada route. Estas funciones pueden devolver tres tipos de datos: Una cadena, o la generaci\u00f3n de una plantilla (que veremos posteriormente). Por defecto se indica un c\u00f3digo 200 y las cabeceras por defecto. Un objeto de la clase response generado con la funci\u00f3n make_repsonse, que recibe los datos devueltos, el c\u00f3digo de estado y las cabeceras. Una tupla con los mismos datos: datos, cabeceras y c\u00f3digo de respuesta.","title":"Generando respuestas HTTP, respuestas de error y redirecciones"},{"location":"4_4_gen_http.html#ejemplo-de-respuestas","text":"Veamos el siguiente c\u00f3digo: from flask import Flask, request, make_response, abort, redirect, url_for ... @app.route('/string/') def return_string(): return 'Hello, world!' @app.route('/object/') def return_object(): headers = {'Content-Type': 'text/plain'} return make_response('Hello, world!', 200,headers) @app.route('/tuple/') def return_tuple(): return 'Hello, world!', 200, {'Content-Type':'text/plain'} Puedes comprobar que devuelve cada una de las rutas.","title":"Ejemplo de respuestas"},{"location":"4_4_gen_http.html#respuestas-de-error","text":"Si queremos que en cualquier momento devolver una respuesta HTTP de error podemos utilizar la funci\u00f3n abort: @app.route('/login') def login(): abort(401) # Esta l\u00ednea no se ejecuta Y lo comprobamos: curl http://localhost:5000/login <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"> <title>401 Unauthorized</title> <h1>Unauthorized</h1> <p>The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.</p> Si queremos responder de la misma manera un determinado c\u00f3digo de estado, por ejemplo queremos devolver una respuesta determinada cuando no se encuentra un recurso: @app.errorhandler(404) def page_not_found(error): return 'P\u00e1gina no encontrada...', 404 curl http://localhost:5000/PaginaNoExiste P\u00e1gina no encontrada...","title":"Respuestas de error"},{"location":"4_4_gen_http.html#redirecciones","text":"Si queremos realizar una redicirecci\u00f3n HTTP a otra URL utilizamos la funci\u00f3n redirect: @app.route('/') def index(): return redirect(url_for('return_string')) C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"Redirecciones"},{"location":"4_5_contenido_estatico.html","text":"Contenido est\u00e1tico \u00b6 Nuestra p\u00e1gina web necesita tener contenido est\u00e1tico: hoja de estilo, ficheros java script, im\u00e1genes, documentos pdf, etc. Para acceder a eelos vamos a utilizar la funci\u00f3n url_for. \u00bfD\u00f3nde guardamos el contenido est\u00e1tico?Permalink Dentro de nuestro directorio aplicacion vamos a crear un directorio llamado static, donde podemos crear la estructura de directorios adecuada para guardas nuestro contenido est\u00e1tico. Por ejemplo para guardar el CSS, el java script y las im\u00e1genes podr\u00edamos crear una estrucutra como la siguiente: aplicacion static css js img Acceder al contenido est\u00e1tico \u00b6 Por ejemplo: url_for('static', filename='css/style.css') Estariamos creando la ruta para acceder al fichero style.css que se encuentra en static/css. Otro ejemplo: url_for('static', filename='img/tux.png') Estar\u00edamos creando la ruta para acceder al fichero tux.png que se encuentra en static/img. Mostrar una imagen \u00b6 @app.route('/') def inicio(): return '<img src=\"'+url_for('static', filename='img/tux.png')+'\"/>' Y comprobamos que se muestra al acceder a la p\u00e1gina: C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"4.5. Contenido Est\u00e1tico"},{"location":"4_5_contenido_estatico.html#contenido-estatico","text":"Nuestra p\u00e1gina web necesita tener contenido est\u00e1tico: hoja de estilo, ficheros java script, im\u00e1genes, documentos pdf, etc. Para acceder a eelos vamos a utilizar la funci\u00f3n url_for. \u00bfD\u00f3nde guardamos el contenido est\u00e1tico?Permalink Dentro de nuestro directorio aplicacion vamos a crear un directorio llamado static, donde podemos crear la estructura de directorios adecuada para guardas nuestro contenido est\u00e1tico. Por ejemplo para guardar el CSS, el java script y las im\u00e1genes podr\u00edamos crear una estrucutra como la siguiente: aplicacion static css js img","title":"Contenido est\u00e1tico"},{"location":"4_5_contenido_estatico.html#acceder-al-contenido-estatico","text":"Por ejemplo: url_for('static', filename='css/style.css') Estariamos creando la ruta para acceder al fichero style.css que se encuentra en static/css. Otro ejemplo: url_for('static', filename='img/tux.png') Estar\u00edamos creando la ruta para acceder al fichero tux.png que se encuentra en static/img.","title":"Acceder al contenido est\u00e1tico"},{"location":"4_5_contenido_estatico.html#mostrar-una-imagen","text":"@app.route('/') def inicio(): return '<img src=\"'+url_for('static', filename='img/tux.png')+'\"/>' Y comprobamos que se muestra al acceder a la p\u00e1gina: C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"Mostrar una imagen"},{"location":"4_6_ejercicios.html","text":"Ejercicios \u00b6 Realiza una aplicaci\u00f3n en Flask con las siguientes caracter\u00edsticas: ruta: / => redirecciona a inicio ruta: /inicio => Muestra Mensaje: Bienvenido a aplicaci\u00f3n + Imagen Paradisiaca ruta: /juguetes/post => Muestra Mensaje: Nuevos jueguetes, con petici\u00f3n POST ruta: /privado => Muestra Mensaje: Error 401, zona protegida Una vez hecho esto, dentro de la carpeta static/img/ a\u00f1ade 3 imagenes de juguetes. Dichos juguetes se deben denominar juguete1.png, juguete2.png y juguete3.png. ruta: /juguetes => Muestra las im\u00e1genes de los 3 juguetes ruta: /juguetes/ => Muestra la imagen del juguete escrito (Sin .png)","title":"4.6. Ejercicios"},{"location":"4_6_ejercicios.html#ejercicios","text":"Realiza una aplicaci\u00f3n en Flask con las siguientes caracter\u00edsticas: ruta: / => redirecciona a inicio ruta: /inicio => Muestra Mensaje: Bienvenido a aplicaci\u00f3n + Imagen Paradisiaca ruta: /juguetes/post => Muestra Mensaje: Nuevos jueguetes, con petici\u00f3n POST ruta: /privado => Muestra Mensaje: Error 401, zona protegida Una vez hecho esto, dentro de la carpeta static/img/ a\u00f1ade 3 imagenes de juguetes. Dichos juguetes se deben denominar juguete1.png, juguete2.png y juguete3.png. ruta: /juguetes => Muestra las im\u00e1genes de los 3 juguetes ruta: /juguetes/ => Muestra la imagen del juguete escrito (Sin .png)","title":"Ejercicios"},{"location":"5_1_plantillas_jinja.html","text":"Plantillas con jinja2 \u00b6 Jinja2 es un motor de plantilla desarrollado en Python. Flask utiliza jinja2 para generar documentos HTML v\u00e1lidos de una manera muy sencilla y eficiente. Por dependencias al instalar Flask instalamos jinja2. En esta unidad vamos a estudiar los elementos principales de jinja2, para m\u00e1s informaci\u00f3n accede a la documentaci\u00f3n oficial de jinja2. Una plantilla simple \u00b6 Veamos un ejemplo para entender como funciona jinja2: from jinja2 import Template temp1=\"Hola \" print(Template(temp1).render(nombre=\"Pepe\")) La salida es Hola Pepe. La plantilla se compone de una variable `` que es sustituida por el valor de la variable nombre al renderizar o generar la plantilla. Elementos de una plantillaPermalink Una plantilla puede estar formada por texto, y algunos de los siguientes elementos: Variables, se indican con {{ ... }} Instrucciones, se indican con {% ... %} Comentarios, se indican con {# ... #} Variables en las plantillasPermalink Las variables en la plantillas se sustituyen por los valores que se pasan a la plantilla al renderizarlas. Si enviamos una lista o un diccionario puedo acceder los valores de dos maneras: Veamos algunos ejemplos: temp2='<a href=\"\"> </a>' print(Template(temp2).render(url=\"http://www.flask.com\",enlace=\"Flask\")) temp3='<a href=\"\"> </a>' print(Template(temp3).render(datos=[\"http://www.flask.com\",\"Flask\"])) temp4='<a href=\"\"> </a>' print(Template(temp4).render(datos={\"url\":\"http://www.flask.com\",\"enlace\":\"Flask\"})) El resultado de las tres plantillas es: <a href=\"http://www.flask.com\"> Flask</a> Filtros de variables \u00b6 Un filtro me permite modificar una variable. Son distintas funciones que me modifican o calculan valores a partir de las variables, se indican separadas de las variables por | y si tienen par\u00e1metros se indican entre par\u00e9ntesis. Veamos algunos ejemplos: temp5='Hola ' print(Template(temp5).render(nombre=\" pepe \")) temp6=\"los datos son {{ lista|join(', ') }}\" print(Template(temp6).render(lista=[\"amarillo\",\"verde\",\"rojo\"])) temp6=\"El ultimo elemento tiene caracteres\" print(Template(temp6).render(lista=[\"amarillo\",\"verde\",\"rojo\"])) Por defecto los caracteres (>, <, &, \") no se escapan, si queremos mostrarlo en nuestra p\u00e1gina HTML tenemos que escapar los caracteres: temp7=\"La siguiente cadena muestra todos los caracteres: \" print(Template(temp7).render(info=\"<hola&que&tal>\")) Y por tanto la salida es: La siguiente cadena muestra todos los caracteres: &lt;hola&amp;que&amp;tal&gt; Para ver todos los filtros accede a la lista de filtros en la documentaci\u00f3n. Instrucciones en las plantillas \u00b6 for \u00b6 Nos permite recorrer una secuencia, veamos un ejemplo sencillo. Es compatible con la sentencia for de python. temp7=''' <ul> {% for elem in elems -%} <li>{{loop.index}} - {{ elem }}</li> {% endfor -%} </ul> ''' print(Template(temp7).render(elems=[\"amarillo\",\"verde\",\"rojo\"])) La salida es: <ul> <li>1 - amarillo</li> <li>2 - verde</li> <li>3 - rojo</li> </ul> El - detr\u00e1s del bloque for evita que se a\u00f1ada una l\u00ednea en blanco. En un bloque for tenemos acceso a varias variables, veamos las m\u00e1s interesantes: loop.index: La iteraci\u00f3n actual del bucle (empieza a contar desde 1). loop.index0: La iteraci\u00f3n actual del bucle (empieza a contar desde 0). loop.first: True si estamos en la primera iteraci\u00f3n. loop.last: True si estamos en la \u00faltima iteraci\u00f3n. loop.length: N\u00famero de iteraciones del bucle. if \u00b6 Nos permite preguntar por el valor de una variable o si una variable existe. Es compatible con la sentencia if de python. Ejemplo: temp9=''' {% if elems %} <ul> {% for elem in elems -%} {% if elem is divisibleby 2 -%} <li>{{elem}} es divisible por 2.</li> {% else -%} <li>{{elem}} no es divisible por 2.</li> {% endif -%} {% endfor -%} </ul> {% endif %} ''' print(Template(temp9).render(elems=[1,2,3,4])) Y la salida ser\u00e1: <ul> <li>1 no es divisible por 2.</li> <li>2 es divisible por 2.</li> <li>3 no es divisible por 2.</li> <li>4 es divisible por 2.</li> </ul> Tenemos un conjunto de tests para realizar comprobaciones, por ejemplo divisibleby devuelve True si un n\u00famero es divible por el que indiquemos. Hay m\u00e1s tests que podemos utilizar. Para ver todos los tests accede a la lista de tests en la documentaci\u00f3n. C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"5.1. Plantillas con jinja2"},{"location":"5_1_plantillas_jinja.html#plantillas-con-jinja2","text":"Jinja2 es un motor de plantilla desarrollado en Python. Flask utiliza jinja2 para generar documentos HTML v\u00e1lidos de una manera muy sencilla y eficiente. Por dependencias al instalar Flask instalamos jinja2. En esta unidad vamos a estudiar los elementos principales de jinja2, para m\u00e1s informaci\u00f3n accede a la documentaci\u00f3n oficial de jinja2.","title":"Plantillas con jinja2"},{"location":"5_1_plantillas_jinja.html#una-plantilla-simple","text":"Veamos un ejemplo para entender como funciona jinja2: from jinja2 import Template temp1=\"Hola \" print(Template(temp1).render(nombre=\"Pepe\")) La salida es Hola Pepe. La plantilla se compone de una variable `` que es sustituida por el valor de la variable nombre al renderizar o generar la plantilla. Elementos de una plantillaPermalink Una plantilla puede estar formada por texto, y algunos de los siguientes elementos: Variables, se indican con {{ ... }} Instrucciones, se indican con {% ... %} Comentarios, se indican con {# ... #} Variables en las plantillasPermalink Las variables en la plantillas se sustituyen por los valores que se pasan a la plantilla al renderizarlas. Si enviamos una lista o un diccionario puedo acceder los valores de dos maneras: Veamos algunos ejemplos: temp2='<a href=\"\"> </a>' print(Template(temp2).render(url=\"http://www.flask.com\",enlace=\"Flask\")) temp3='<a href=\"\"> </a>' print(Template(temp3).render(datos=[\"http://www.flask.com\",\"Flask\"])) temp4='<a href=\"\"> </a>' print(Template(temp4).render(datos={\"url\":\"http://www.flask.com\",\"enlace\":\"Flask\"})) El resultado de las tres plantillas es: <a href=\"http://www.flask.com\"> Flask</a>","title":"Una plantilla simple"},{"location":"5_1_plantillas_jinja.html#filtros-de-variables","text":"Un filtro me permite modificar una variable. Son distintas funciones que me modifican o calculan valores a partir de las variables, se indican separadas de las variables por | y si tienen par\u00e1metros se indican entre par\u00e9ntesis. Veamos algunos ejemplos: temp5='Hola ' print(Template(temp5).render(nombre=\" pepe \")) temp6=\"los datos son {{ lista|join(', ') }}\" print(Template(temp6).render(lista=[\"amarillo\",\"verde\",\"rojo\"])) temp6=\"El ultimo elemento tiene caracteres\" print(Template(temp6).render(lista=[\"amarillo\",\"verde\",\"rojo\"])) Por defecto los caracteres (>, <, &, \") no se escapan, si queremos mostrarlo en nuestra p\u00e1gina HTML tenemos que escapar los caracteres: temp7=\"La siguiente cadena muestra todos los caracteres: \" print(Template(temp7).render(info=\"<hola&que&tal>\")) Y por tanto la salida es: La siguiente cadena muestra todos los caracteres: &lt;hola&amp;que&amp;tal&gt; Para ver todos los filtros accede a la lista de filtros en la documentaci\u00f3n.","title":"Filtros de variables"},{"location":"5_1_plantillas_jinja.html#instrucciones-en-las-plantillas","text":"","title":"Instrucciones en las plantillas"},{"location":"5_1_plantillas_jinja.html#for","text":"Nos permite recorrer una secuencia, veamos un ejemplo sencillo. Es compatible con la sentencia for de python. temp7=''' <ul> {% for elem in elems -%} <li>{{loop.index}} - {{ elem }}</li> {% endfor -%} </ul> ''' print(Template(temp7).render(elems=[\"amarillo\",\"verde\",\"rojo\"])) La salida es: <ul> <li>1 - amarillo</li> <li>2 - verde</li> <li>3 - rojo</li> </ul> El - detr\u00e1s del bloque for evita que se a\u00f1ada una l\u00ednea en blanco. En un bloque for tenemos acceso a varias variables, veamos las m\u00e1s interesantes: loop.index: La iteraci\u00f3n actual del bucle (empieza a contar desde 1). loop.index0: La iteraci\u00f3n actual del bucle (empieza a contar desde 0). loop.first: True si estamos en la primera iteraci\u00f3n. loop.last: True si estamos en la \u00faltima iteraci\u00f3n. loop.length: N\u00famero de iteraciones del bucle.","title":"for"},{"location":"5_1_plantillas_jinja.html#if","text":"Nos permite preguntar por el valor de una variable o si una variable existe. Es compatible con la sentencia if de python. Ejemplo: temp9=''' {% if elems %} <ul> {% for elem in elems -%} {% if elem is divisibleby 2 -%} <li>{{elem}} es divisible por 2.</li> {% else -%} <li>{{elem}} no es divisible por 2.</li> {% endif -%} {% endfor -%} </ul> {% endif %} ''' print(Template(temp9).render(elems=[1,2,3,4])) Y la salida ser\u00e1: <ul> <li>1 no es divisible por 2.</li> <li>2 es divisible por 2.</li> <li>3 no es divisible por 2.</li> <li>4 es divisible por 2.</li> </ul> Tenemos un conjunto de tests para realizar comprobaciones, por ejemplo divisibleby devuelve True si un n\u00famero es divible por el que indiquemos. Hay m\u00e1s tests que podemos utilizar. Para ver todos los tests accede a la lista de tests en la documentaci\u00f3n. C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"if"},{"location":"5_2_flask_jinja.html","text":"Generando p\u00e1ginas HTML con Flask y Jinja2 \u00b6 Flask utiliza por defecto jinja2 para generar documentos HTML, para generar una plantilla utilizamos la funci\u00f3n render_template que recibe como par\u00e1metro el fichero donde guardamos la plantilla y las variables que se pasan a esta. Las plantillas las vamos a guardar en ficheros en el directorio templates (dentro del directorio aplicacion). As\u00ed que primero crearemos el directorio template. Plantilla simple \u00b6 Veamos un ejemplo de c\u00f3mo podemos generar HTML a partir de una plantilla en Flask, el programa ser\u00e1 el siguiente: ... @app.route('/hola/') @app.route('/hola/<nombre>') def saluda(nombre=None): return render_template(\"template1.html\",nombre=nombre) La plantilla: template1.html \u00b6 <!DOCTYPE html> <html lang=\"es\"> <head> <title>Hola, que tal {{nombre}}</title> <meta charset=\"utf-8\" /> </head> <body> <header> <h1>Mi sitio web</h1> <p>Mi sitio web creado en html5</p> </header> <h2>Vamos a saludar</h2> {% if nombre %} <h1>Hola {{nombre|title}}</h1> <p>\u00bfC\u00f3mo est\u00e1s?</p> {%else%} <p>No has indicado un nombre</p> {% endif %} </body> </html> Y la salida: Env\u00edo de varias variables a una plantilla \u00b6 En este caso veremos un ejemplo donde mandamos varias variables a la plantilla: @app.route('/suma/<num1>/<num2>') def suma(num1,num2): try: resultado=int(num1)+int(num2) except: abort(404) return render_template(\"template2.html\",num1=num1,num2=num2,resultado=resultado) La plantilla: template2.html \u00b6 ... <h2>Suma</h2> {% if resultado>0 %} <p>El resultado es positivo</p> {%else%} <p>El resultado es negativo</p> {% endif %} <h3>{{resultado}}</h3> ... Y la salida: Generando p\u00e1ginas de error con plantillas \u00b6 Como vemos en el ejemplo anterior, si los n\u00fameros no se pueden sumar se generara una respuesta 404, podemos tambi\u00e9n generar esta p\u00e1gina a partir de una plantilla: @app.errorhandler(404) def page_not_found(error): return render_template(\"error.html\",error=\"P\u00e1gina no encontrada...\"), 404 La plantilla: error.html \u00b6 ... <header> <h1>{{error}}</h1> <img src=\"{{ url_for('static', filename='img/tux.png')}}\"/> </header> ... Uso de for en una plantilla \u00b6 En este caso vamos a mostrar la tabla de multiplicar de un n\u00famero, en la plantilla vamos a generar un bucle con 10 iteraciones usando el tipo de datos range: @app.route('/tabla/<numero>') def tabla(numero): try: numero=int(numero) except: abort(404) return render_template(\"template3.html\",num=numero) La plantilla: template3.html \u00b6 ... <h2>Tabla de multiplicar</h2> {% for i in range(1,11) -%} <p>{{num}} * {{i}} = {{num*i}}</p> {% endfor -%} ... Y la salida: Env\u00edo de diccionario a una plantilla \u00b6 En realidad vamos a mandar una lista de diccionarios, donde tenemos informaci\u00f3n para construir un enlace: @app.route('/enlaces') def enlaces(): enlaces=[{\"url\":\"http://www.google.es\",\"texto\":\"Google\"}, {\"url\":\"http://www.twitter.com\",\"texto\":\"Twitter\"}, {\"url\":\"http://www.facbook.com\",\"texto\":\"Facebook\"}, ] return render_template(\"template4.html\",enlaces=enlaces) La plantilla: template4.html. \u00b6 ... <h2>Enlaces</h2> {% if enlaces %} <ul> {% for enlace in enlaces -%} <li><a href=\"{{ enlace.url }}\">{{ enlace.texto }}</a></li> {% endfor -%} </ul> {% else %} <p>No hay enlaces></p> {% endif %} ... Y la salida: C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"5.2 Generando p\u00e1ginas HTML con Flask y Jinja2"},{"location":"5_2_flask_jinja.html#generando-paginas-html-con-flask-y-jinja2","text":"Flask utiliza por defecto jinja2 para generar documentos HTML, para generar una plantilla utilizamos la funci\u00f3n render_template que recibe como par\u00e1metro el fichero donde guardamos la plantilla y las variables que se pasan a esta. Las plantillas las vamos a guardar en ficheros en el directorio templates (dentro del directorio aplicacion). As\u00ed que primero crearemos el directorio template.","title":"Generando p\u00e1ginas HTML con Flask y Jinja2"},{"location":"5_2_flask_jinja.html#plantilla-simple","text":"Veamos un ejemplo de c\u00f3mo podemos generar HTML a partir de una plantilla en Flask, el programa ser\u00e1 el siguiente: ... @app.route('/hola/') @app.route('/hola/<nombre>') def saluda(nombre=None): return render_template(\"template1.html\",nombre=nombre) La plantilla:","title":"Plantilla simple"},{"location":"5_2_flask_jinja.html#envio-de-varias-variables-a-una-plantilla","text":"En este caso veremos un ejemplo donde mandamos varias variables a la plantilla: @app.route('/suma/<num1>/<num2>') def suma(num1,num2): try: resultado=int(num1)+int(num2) except: abort(404) return render_template(\"template2.html\",num1=num1,num2=num2,resultado=resultado) La plantilla:","title":"Env\u00edo de varias variables a una plantilla"},{"location":"5_2_flask_jinja.html#generando-paginas-de-error-con-plantillas","text":"Como vemos en el ejemplo anterior, si los n\u00fameros no se pueden sumar se generara una respuesta 404, podemos tambi\u00e9n generar esta p\u00e1gina a partir de una plantilla: @app.errorhandler(404) def page_not_found(error): return render_template(\"error.html\",error=\"P\u00e1gina no encontrada...\"), 404 La plantilla:","title":"Generando p\u00e1ginas de error con plantillas"},{"location":"5_2_flask_jinja.html#uso-de-for-en-una-plantilla","text":"En este caso vamos a mostrar la tabla de multiplicar de un n\u00famero, en la plantilla vamos a generar un bucle con 10 iteraciones usando el tipo de datos range: @app.route('/tabla/<numero>') def tabla(numero): try: numero=int(numero) except: abort(404) return render_template(\"template3.html\",num=numero) La plantilla:","title":"Uso de for en una plantilla"},{"location":"5_2_flask_jinja.html#envio-de-diccionario-a-una-plantilla","text":"En realidad vamos a mandar una lista de diccionarios, donde tenemos informaci\u00f3n para construir un enlace: @app.route('/enlaces') def enlaces(): enlaces=[{\"url\":\"http://www.google.es\",\"texto\":\"Google\"}, {\"url\":\"http://www.twitter.com\",\"texto\":\"Twitter\"}, {\"url\":\"http://www.facbook.com\",\"texto\":\"Facebook\"}, ] return render_template(\"template4.html\",enlaces=enlaces) La plantilla:","title":"Env\u00edo de diccionario a una plantilla"},{"location":"5_3_herencia_plan.html","text":"Herencia de plantillas \u00b6 La herencia de plantillas nos permite hacer un esqueleto de plantilla, para que todas las p\u00e1ginas de nuestro sitio web sean similares. En la unidad anterior hicimos una plantilla independiente para cada p\u00e1gina, eso tiene un problema: si queremos cambiar algo que es com\u00fan a todas las p\u00e1ginas hay que cambiarlo en todos los ficheros. En nuestro caso vamos a crear una plantilla base de donde se van a heredar todas las dem\u00e1s, e indicaremos los bloques que las plantillas hijas pueden sobreescribir. La plantilla base \u00b6 Vamos a crear una plantilla base.html donde indicaremos las partes comunes de todas nuestras p\u00e1ginas, e indicaremos los bloques que las otras plantillas pueden reescribir. base.html \u00b6 <!DOCTYPE html> <html lang=\"es\"> <head> <title>{% block title %}{% endblock %}</title> <link rel=\"stylesheet\" href=\"{{url_for(\"static\", filename='css/style.css')}}\"> <meta charset=\"utf-8\" /> </head> <body> <header> <h1>Mi sitio web</h1> <p>Mi sitio web creado en html5</p> </header> {% block content %}{% endblock %} </body> </html> Algunas consideraciones: Hemos creado dos bloques (title y content) en las plantillas hijas vamos a poder rescribir esos dos bloque para poner el t\u00edtulo de la p\u00e1gina y el contenido. Podr\u00edamos indicar todos los bloques que necesitamos. Hemos incluido una hoja de estilo que est\u00e1 en nuestro contenido est\u00e1tico (directorio static) Herencia de plantillas \u00b6 A continuaci\u00f3n, veamos la primera plantilla (template1.html) utilizando la t\u00e9cnica de herencia: template1.html \u00b6 {% extends \"base.html\" %} {% block title %}Hola, que tal {{nombre}}{% endblock %} {% block content %} <h2>Vamos a saludar</h2> {% if nombre %} <h1>Hola {{nombre|title}}</h1> <p>\u00bfC\u00f3mo est\u00e1s?</p> {%else%} <p>No has indicado un nombre</p> {% endif %} {% endblock %} Observamos c\u00f3mo hemos reescrito los dos bloques. Ejecuta el programa y comprueba que se genera el documento HTML completo, comprueba tambi\u00e9n que se est\u00e1 usando una hoja de estilo. El c\u00f3digo css es el siguiente: css/style.css \u00b6 body { font: 62.5%/1.5 \"Lucida Grande\", \"Lucida Sans\", Tahoma, Verdana, sans-serif; color: \"#22222\"; text-align:\"center\"; } h1 { font-size: 2.2em; } h2 { font-size: 2.0em; } h3 { font-size: 1.8em; } h4 { font-size: 1.6em; } h5 { font-size: 1.4em; } p { font-size: 1.2em; } Puedes ver el dise\u00f1o de las dem\u00e1s plantillas en el c\u00f3digo ejemplo. C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"5.3 Herencia de plantillas"},{"location":"5_3_herencia_plan.html#herencia-de-plantillas","text":"La herencia de plantillas nos permite hacer un esqueleto de plantilla, para que todas las p\u00e1ginas de nuestro sitio web sean similares. En la unidad anterior hicimos una plantilla independiente para cada p\u00e1gina, eso tiene un problema: si queremos cambiar algo que es com\u00fan a todas las p\u00e1ginas hay que cambiarlo en todos los ficheros. En nuestro caso vamos a crear una plantilla base de donde se van a heredar todas las dem\u00e1s, e indicaremos los bloques que las plantillas hijas pueden sobreescribir.","title":"Herencia de plantillas"},{"location":"5_3_herencia_plan.html#la-plantilla-base","text":"Vamos a crear una plantilla base.html donde indicaremos las partes comunes de todas nuestras p\u00e1ginas, e indicaremos los bloques que las otras plantillas pueden reescribir.","title":"La plantilla base"},{"location":"5_3_herencia_plan.html#herencia-de-plantillas_1","text":"A continuaci\u00f3n, veamos la primera plantilla (template1.html) utilizando la t\u00e9cnica de herencia:","title":"Herencia de plantillas"},{"location":"5_3_herencia_plan.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"5_4_plant_boostrap.html","text":"Plantillas con bootstrap (flask-bootstrap) \u00b6 Podemos utilizar la hoja de estilo que queramos, la podemos guardar en nuestro contenido est\u00e1tico o acceder por medio de una url. Sin embargo si queremos trabajar con plantillas que utilicen como hoja de estilos y javascript el framework bootstrap podemos utilizar la extensi\u00f3n Flask-Bootstrap. Instalaci\u00f3n de Flask-Bootstrap \u00b6 Con nuestro entorno virtual activado: pip install Flask-Bootstrap Configuraci\u00f3n de nuestra aplicaci\u00f3n \u00b6 En nuestra aplicaci\u00f3n escribimos lo siguiente: from flask import Flask, render_template, abort from flask_bootstrap import Bootstrap app = Flask(__name__) Bootstrap(app) ... Est\u00e1 l\u00edneas generan una plantilla base de la que podemos extender las nuestras. Uso de la plantilla base bootstrap \u00b6 Por ejemplo nuestra primera plantilla quedar\u00eda: {% extends \"bootstrap/base.html\" %} {% block title %}Hola, que tal {{nombre}}{% endblock %} {% block content %} <h2>Vamos a saludar</h2> {% if nombre %} <h1>Hola {{nombre|title}}</h1> <p>\u00bfC\u00f3mo est\u00e1s?</p> {%else%} <p>No has indicado un nombre</p> {% endif %} {% endblock %} La plantilla base de bootstrap ofrece los siguientes bloques que podemos sobreescribir: html: Contiene el contenido completo de la etiqueta <html> . html_attribs: Atribulos para la etiqueta <html> . head: Contiene el contenido completo de la etiqueta <head> . body: Contiene el contenido completo de la etiqueta <body> . body_attribs: Atribulos para la etiqueta <body> . title: Contiene el contenido completo de la etiqueta <title> . styles: Contiene todos los estilos CSS de la etiqueta <link> . metas: Contiene los <meta> de la cabacera. navbar: Un bloque vac\u00edo encima del contenido. content: Bloque para poner nuestro contenido. scripts: Contiene todos los scripts en la etiqueta <script> al final del body. Ejemplos \u00b6 A\u00f1adiendo otro fichero de hoja de estilo: {% block styles %} {{super()}} <link rel=\"stylesheet\" href=\"{{url_for('.static', filename='mystyle.css')}}\"> {% endblock %} A\u00f1adiendo otro fichero Javascript: {% block scripts %} <script src=\"{{url_for('.static', filename='myscripts.js')}}\"></script> {{super()}} {% endblock %} A\u00f1adiendo el idioma espa\u00f1ol en los atributos de <html> : {% block html_attribs %} lang=\"es\"{% endblock %} C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"5.4 Plantillas con bootstrap (flask-bootstrap)"},{"location":"5_4_plant_boostrap.html#plantillas-con-bootstrap-flask-bootstrap","text":"Podemos utilizar la hoja de estilo que queramos, la podemos guardar en nuestro contenido est\u00e1tico o acceder por medio de una url. Sin embargo si queremos trabajar con plantillas que utilicen como hoja de estilos y javascript el framework bootstrap podemos utilizar la extensi\u00f3n Flask-Bootstrap.","title":"Plantillas con bootstrap (flask-bootstrap)"},{"location":"5_4_plant_boostrap.html#instalacion-de-flask-bootstrap","text":"Con nuestro entorno virtual activado: pip install Flask-Bootstrap","title":"Instalaci\u00f3n de Flask-Bootstrap"},{"location":"5_4_plant_boostrap.html#configuracion-de-nuestra-aplicacion","text":"En nuestra aplicaci\u00f3n escribimos lo siguiente: from flask import Flask, render_template, abort from flask_bootstrap import Bootstrap app = Flask(__name__) Bootstrap(app) ... Est\u00e1 l\u00edneas generan una plantilla base de la que podemos extender las nuestras.","title":"Configuraci\u00f3n de nuestra aplicaci\u00f3n"},{"location":"5_4_plant_boostrap.html#uso-de-la-plantilla-base-bootstrap","text":"Por ejemplo nuestra primera plantilla quedar\u00eda: {% extends \"bootstrap/base.html\" %} {% block title %}Hola, que tal {{nombre}}{% endblock %} {% block content %} <h2>Vamos a saludar</h2> {% if nombre %} <h1>Hola {{nombre|title}}</h1> <p>\u00bfC\u00f3mo est\u00e1s?</p> {%else%} <p>No has indicado un nombre</p> {% endif %} {% endblock %} La plantilla base de bootstrap ofrece los siguientes bloques que podemos sobreescribir: html: Contiene el contenido completo de la etiqueta <html> . html_attribs: Atribulos para la etiqueta <html> . head: Contiene el contenido completo de la etiqueta <head> . body: Contiene el contenido completo de la etiqueta <body> . body_attribs: Atribulos para la etiqueta <body> . title: Contiene el contenido completo de la etiqueta <title> . styles: Contiene todos los estilos CSS de la etiqueta <link> . metas: Contiene los <meta> de la cabacera. navbar: Un bloque vac\u00edo encima del contenido. content: Bloque para poner nuestro contenido. scripts: Contiene todos los scripts en la etiqueta <script> al final del body.","title":"Uso de la plantilla base bootstrap"},{"location":"5_4_plant_boostrap.html#ejemplos","text":"A\u00f1adiendo otro fichero de hoja de estilo: {% block styles %} {{super()}} <link rel=\"stylesheet\" href=\"{{url_for('.static', filename='mystyle.css')}}\"> {% endblock %} A\u00f1adiendo otro fichero Javascript: {% block scripts %} <script src=\"{{url_for('.static', filename='myscripts.js')}}\"></script> {{super()}} {% endblock %} A\u00f1adiendo el idioma espa\u00f1ol en los atributos de <html> : {% block html_attribs %} lang=\"es\"{% endblock %} C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"Ejemplos"},{"location":"5_5_formularios.html","text":"Trabajando con formularios \u00b6 La manera m\u00e1s usual de enviar informaci\u00f3n a las distintas p\u00e1ginas de nuestra aplicaci\u00f3n web es usando formularios HTML5. Es recomendable utilizar el m\u00e9todo POST (la informaci\u00f3n se env\u00eda en el cuerpo de la petici\u00f3n) para el env\u00edo de informaci\u00f3n usando formularios, aunque si es necesario tambi\u00e9n podemos usar el m\u00e9todo GET (la informaci\u00f3n se env\u00eda en la URL de la petici\u00f3n). Ejemplo de calculadora \u00b6 En el c\u00f3digo ejemplo de esta unidad hemos desarrollado una calculadora, en una plantilla creamos un formulario donde se piden dos n\u00fameros y un operador. Seg\u00fan el operador seleccionado, se muestra el resultado. Calculadora con POST \u00b6 Como hemos indicado anteriormente al enviar la informaci\u00f3n con un formulario se manda con el m\u00e9todo POST. Cuando accedemos la primera vez a la ruta /calculadora_post lo estamos haciendo usando el m\u00e9todo GET por lo tanto nos devuelve una plantilla donde mostramos el formulario (la plantilla se llama calculadora_post.html): template/calculadora_post.html \u00b6 {% extends \"base.html\" %} {% block title %}Calculadora{% endblock %} {% block contenido %} <h2>Calculadora</h2> <form action={{url_for(\"calculadora_post\")}} method=\"post\"> N\u00famero1: <input type=\"text\" name=\"num1\" autofocus required /> <br /> N\u00famero2: <input type=\"text\" name=\"num2\" autofocus required /> <br /> Operaci\u00f3n: <select name=\"operador\"> <option value=\"+\">Suma</option> <option value=\"-\">Resta</option> <option value=\"*\">Multiplicaci\u00f3n</option> <option value=\"/\">Divisi\u00f3n</option> </select> <br/> <input type=\"submit\" value=\"Submit!\" /> </form> {% endblock %} Mandamos tres datos: num1, num2 y operador a la misma ruta /calculadora_post pero en esta ocasi\u00f3n se utiliza el m\u00e9todo POST, en este caso se lee los datos del formulario, se calcula la operaci\u00f3n y se muestra una plantilla con el resultado: A\u00f1adir a app.py \u00b6 @app.route(\"/calculadora_post\", methods=[\"get\",\"post\"]) def calculadora_post(): if request.method==\"POST\": num1=request.form.get(\"num1\") num2=request.form.get(\"num2\") operador=request.form.get(\"operador\") try: resultado=eval(num1+operador+num2) except: return render_template(\"error.html\",error=\"No puedo realizar la operaci\u00f3n\") return render_template(\"resultado.html\",num1=num1,num2=num2,operador=operador,resultado=resultado) else: return render_template(\"calculadora_post.html\") Calculadora con GET \u00b6 No es habitual pero vemos el mismo programa pero en este caso enviando la informaci\u00f3n del formulario con el m\u00e9todo GET. En este caso al acceder a la ruta /calculadora_get tenemos que determinar si es la primera vez que hemos accedido, para ello comprobamos si la URL tiene alg\u00fan argumento (len(request.args)>0) sino tiene argumentos mostramos una plantilla con el formulario, igual que en la anterior excepto en la definici\u00f3n del formulario: ... <form action={{url_for(\"calculadora_get\")}} method=\"get\"> ... Si la URL tiene par\u00e1metros (len(request.args)>0) leemos los par\u00e1metros y realizamos la operaci\u00f3n, ser\u00eda similar al programa anterior, lo que cambia es c\u00f3mo se leen los par\u00e1metros de la URL: @app.route(\"/calculadora_get\", methods=[\"get\"]) def calculadora_get(): if request.method==\"GET\" and len(request.args)>0: num1=request.args.get(\"num1\") num2=request.args.get(\"num2\") operador=request.args.get(\"operador\") ... Utilizar rutas din\u00e1micas \u00b6 Cuando se env\u00eda informaci\u00f3n con formularios debemos usar el m\u00e9todo POST, si vamos a mandar informaci\u00f3n en la URL deber\u00edamos usar rutas din\u00e1micas: @app.route(\"/calculadora/<operador>/<num1>/<num2>\", methods=[\"get\"]) def calculadora_var(operador,num1,num2): ... Formulario completo \u00b6 En otro ejercicio del c\u00f3digo ejemplo, puedes comprobar que hemos realizado un formulario con muchos tipos de campos, c\u00f3mo hemos le\u00eddo esa informaci\u00f3n y la hemos enviado a una plantilla para mostrarlos. (\u00a1\u00a1\u00a1Comprueba en el c\u00f3digo la contrase\u00f1a que tienes que introducir para que el programa funcione!!!) C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"5.5 Trabajando con formularios"},{"location":"5_5_formularios.html#trabajando-con-formularios","text":"La manera m\u00e1s usual de enviar informaci\u00f3n a las distintas p\u00e1ginas de nuestra aplicaci\u00f3n web es usando formularios HTML5. Es recomendable utilizar el m\u00e9todo POST (la informaci\u00f3n se env\u00eda en el cuerpo de la petici\u00f3n) para el env\u00edo de informaci\u00f3n usando formularios, aunque si es necesario tambi\u00e9n podemos usar el m\u00e9todo GET (la informaci\u00f3n se env\u00eda en la URL de la petici\u00f3n).","title":"Trabajando con formularios"},{"location":"5_5_formularios.html#ejemplo-de-calculadora","text":"En el c\u00f3digo ejemplo de esta unidad hemos desarrollado una calculadora, en una plantilla creamos un formulario donde se piden dos n\u00fameros y un operador. Seg\u00fan el operador seleccionado, se muestra el resultado.","title":"Ejemplo de calculadora"},{"location":"5_5_formularios.html#calculadora-con-post","text":"Como hemos indicado anteriormente al enviar la informaci\u00f3n con un formulario se manda con el m\u00e9todo POST. Cuando accedemos la primera vez a la ruta /calculadora_post lo estamos haciendo usando el m\u00e9todo GET por lo tanto nos devuelve una plantilla donde mostramos el formulario (la plantilla se llama calculadora_post.html):","title":"Calculadora con POST"},{"location":"5_5_formularios.html#calculadora-con-get","text":"No es habitual pero vemos el mismo programa pero en este caso enviando la informaci\u00f3n del formulario con el m\u00e9todo GET. En este caso al acceder a la ruta /calculadora_get tenemos que determinar si es la primera vez que hemos accedido, para ello comprobamos si la URL tiene alg\u00fan argumento (len(request.args)>0) sino tiene argumentos mostramos una plantilla con el formulario, igual que en la anterior excepto en la definici\u00f3n del formulario: ... <form action={{url_for(\"calculadora_get\")}} method=\"get\"> ... Si la URL tiene par\u00e1metros (len(request.args)>0) leemos los par\u00e1metros y realizamos la operaci\u00f3n, ser\u00eda similar al programa anterior, lo que cambia es c\u00f3mo se leen los par\u00e1metros de la URL: @app.route(\"/calculadora_get\", methods=[\"get\"]) def calculadora_get(): if request.method==\"GET\" and len(request.args)>0: num1=request.args.get(\"num1\") num2=request.args.get(\"num2\") operador=request.args.get(\"operador\") ...","title":"Calculadora con GET"},{"location":"5_5_formularios.html#utilizar-rutas-dinamicas","text":"Cuando se env\u00eda informaci\u00f3n con formularios debemos usar el m\u00e9todo POST, si vamos a mandar informaci\u00f3n en la URL deber\u00edamos usar rutas din\u00e1micas: @app.route(\"/calculadora/<operador>/<num1>/<num2>\", methods=[\"get\"]) def calculadora_var(operador,num1,num2): ...","title":"Utilizar rutas din\u00e1micas"},{"location":"5_5_formularios.html#formulario-completo","text":"En otro ejercicio del c\u00f3digo ejemplo, puedes comprobar que hemos realizado un formulario con muchos tipos de campos, c\u00f3mo hemos le\u00eddo esa informaci\u00f3n y la hemos enviado a una plantilla para mostrarlos. (\u00a1\u00a1\u00a1Comprueba en el c\u00f3digo la contrase\u00f1a que tienes que introducir para que el programa funcione!!!) C\u00f3digo ejemplo de esta unidad C\u00f3digo","title":"Formulario completo"},{"location":"5_6_formularios_flask_wtf.html","text":"Generando formularios con flask-wtf \u00b6 Flask-WTF es una extensi\u00f3n de Flask que nos permite trabajar con la librer\u00eda WTForm de python, que nos facilita la generaci\u00f3n y validaci\u00f3n de formularios HTML. Instalaci\u00f3n de Flask-WTF \u00b6 Con nuestro entorno virtual ejecutamos: pip install Flask-WTF Por dependencia se instala la librer\u00eda WTForm. Creando formularios \u00b6 En el directorio de nuestra aplicaci\u00f3n (aplicacion) vamos a crear un fichero (forms.py) donde vamos a guardar los distintos formularios de nuestra aplicaci\u00f3n. Por ejemplo el fichero forms.py: forms.py \u00b6 from flask_wtf import FlaskForm from wtforms import Form, IntegerField,SelectField,SubmitField from wtforms.validators import DataRequired class formcalculadora(FlaskForm): num1=IntegerField(\"N\u00famero1\",validators=[DataRequired(\"Tienes que introducir el dato\")]) num2=IntegerField(\"N\u00famero2\",validators=[DataRequired(\"Tienes que introducir el dato\")]) operador=SelectField(\"Operador\",choices=[(\"+\",\"Sumar\"),(\"-\",\"Resta\"), (\"*\",\"Multiplicar\"),(\"/\",\"Dividir\")]) submit = SubmitField('Submit') Como puedes ver hemos creado una clase heredada de la clase FlaskForm donde hemos indicado distintos atributos que son objetos de los distintos tipos de campos que podemos indicar, donde inicializamos distintos datos (label, validaciones,\u2026). Trabajando con formularios \u00b6 En nuestra aplicaci\u00f3n app.py tenemos que importar la clase que hemos creado: from aplicacion.forms import formcalculadora Y a continuaci\u00f3n podemos crear un objeto a partir de ella: form = formcalculadora() Al crear el formulario podemos inicialzarlos con datos, normalmente con los par\u00e1metros recibidos en la vista (request.form): form = formcalculadora(request.form) El objeto form nos ofrece algunos atributos y m\u00e9todos para su gesti\u00f3n: form.validate_on_submit(): Nos permite comprobar si el formulario ha sido enviado y es v\u00e1lido. form.data: Nos ofrece un diccionario con los datos del formulario. form.errors: Si el formulario no es v\u00e1lido nos devuelve un diccionario con los errores. form.num1.data: Para cada campo (en este ejemplo num1)`nos devuelve su valor. form.num1.errors: Es una tupla con los errores de validaci\u00f3n de el campo determinado. form.num1(): Nos devuelve el c\u00f3digo HTML para generar este campo. form.num1.label(): Nos devuelve el c\u00f3digo HTML para general la etiqueta del campo. Puedes encontrar m\u00e1s atributos y m\u00e9todos en la documentaci\u00f3n de WTForm . Seguridad en los formularios \u00b6 Por defecto Flask-WTF protege los formularios contra el ataque CSRF (Cross-Site Request Forgery o falsificaci\u00f3n de petici\u00f3n en sitios cruzados). Este ataque se produce cuando un sitio web malicioso env\u00eda solicitudes a un sitio web en el que est\u00e1 conectada la v\u00edctima. Para implementar la protecci\u00f3n CSRF, Flask-WTF necesita que configuremos una clave de cifrado, para generar tokens encriptados que se utilizar\u00e1n para verificar la autenticidad de la petici\u00f3n. Para ello, en nuestro programa principal: app.secret_key = 'clave de cifrado lo m\u00e1s robusta posible' Cada vez que generemos un formulario se incluir\u00e1 un campo oculto que contendr\u00e1 el token cifrado que permitir\u00e1 verificar que el envi\u00f3 del formulario ha sido l\u00edcita. Para generar este campo oculto utilizamos el m\u00e9todo form.csrf_token() que mostrar\u00e1 un c\u00f3digo HTML parecido a este: <input id=\"csrf_token\" name=\"csrf_token\" type=\"hidden\" value=\"IjE5OWRiYmY0MGE2MT...\"> Generaci\u00f3n de formularios \u00b6 En nuestra plantillas, podemos generar el formulario campo por campo, por ejemplo: <form action={{url_for(\"calculadora_post\")}} method=\"post\"> {{ form.csrf_token }} {{form.num1.label() }}{{form.num1()}}<br/> {{form.num2.label() }}{{form.num2()}}<br/> {{form.operador.label() }}{{form.operador()}}<br/> <br/> {{form.submit()}} </form> Tambi\u00e9n tenemos la opci\u00f3n de recorrer el formulario: <form action={{url_for(\"calculadora_post\")}} method=\"post\"> {% for field in form %} {{field.label() }}{{field()}}<br/> {% endfor %} </form> Para mostrar los errores de validaci\u00f3n podemos realizar un recorrido similar a este: {% for field, errors in form.errors.items() %} <div class=\"alert alert-danger\"> {{ form[field].label }}: {{ ', '.join(errors) }} </div> {% endfor %} Quedando el template/calculadora_post.html de la siguiente forma: calculadora_post.html \u00b6 {% extends \"base.html\" %} {% block title %}Calculadora{% endblock %} {% block contenido %} <h2>Calculadora</h2> {% for field, errors in form.errors.items() %} <div class=\"alert alert-danger\"> {{ form[field].label }}: {{ ', '.join(errors) }} </div> {% endfor %} <form action={{url_for(\"calculadora_post\")}} method=\"post\"> <!-- {% for field in form %} {{field.label() }}{{field()}}<br/> {% endfor %} --> {{ form.csrf_token }} {{form.num1.label() }}{{form.num1()}}<br/> {{form.num2.label() }}{{form.num2()}}<br/> {{form.operador.label() }}{{form.operador()}}<br/> <br/> {{form.submit()}} </form> {% endblock %} Enviando y gestionando la informaci\u00f3n del formulario \u00b6 Vamos a usar un patr\u00f3n de dise\u00f1o basado en la creaci\u00f3n de una vista que se comporte de la siguiente manera: La primera vez que accedemos a la ruta accedemos utilizando el m\u00e9todo GET. En nuestro caso se crear\u00e1 un formulario sin datos (ya que request.form no tiene ning\u00fan dato) , el formulario no se ha enviado y por lo tanto se devuelve la plantilla con el formulario vac\u00edo. Se rellena el formulario y se manda la informaci\u00f3n a la misma ruta pero utilizando el m\u00e9todo POST. En este caso se crea un formulario que se rellena con la informaci\u00f3n que se ha recibido del formulario. Si el formulario es v\u00e1lido se gestiona la informaci\u00f3n y se realiza la acci\u00f3n que se tenga que hacer (guardar en una base de datos, mostrar una plantilla resultado,\u2026) Si el formulario no es v\u00e1lido se vuelve a generar la plantilla con el formulario con datos, mostrando si lo hemos codificado los errores de validaci\u00f3n oportunos. En nuestro caso la llamada a la vista que hemos puesto en nuestro ejemplo de la calculadora quedar\u00eda de la siguiente manera: app.py \u00b6 @app.route(\"/calculadora_post\", methods=[\"get\",\"post\"]) def calculadora_post(): form=formcalculadora(request.form) if form.validate_on_submit(): num1=form.num1.data num2=form.num2.data operador=form.operador.data try: resultado=eval(str(num1)+operador+str(num2)) except: return render_template(\"error.html\",error=\"No puedo realizar la operaci\u00f3n\") return render_template(\"resultado.html\",num1=num1,num2=num2,operador=operador,resultado=resultado) else: return render_template(\"calculadora_post.html\",form=form) resultado.html \u00b6 {% extends \"base.html\" %} {% block title %}Calculadora{% endblock %} {% block contenido %} <h2>Resultado Calculadora</h2> <h3>{{num1}}{{operador}}{{num2}}={{resultado}}</h3> <a href=\"{{url_for('inicio')}}\">Volver</a> {% endblock %} C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"5.6 Generando formularios con flask-wtf"},{"location":"5_6_formularios_flask_wtf.html#generando-formularios-con-flask-wtf","text":"Flask-WTF es una extensi\u00f3n de Flask que nos permite trabajar con la librer\u00eda WTForm de python, que nos facilita la generaci\u00f3n y validaci\u00f3n de formularios HTML.","title":"Generando formularios con flask-wtf"},{"location":"5_6_formularios_flask_wtf.html#instalacion-de-flask-wtf","text":"Con nuestro entorno virtual ejecutamos: pip install Flask-WTF Por dependencia se instala la librer\u00eda WTForm.","title":"Instalaci\u00f3n de Flask-WTF"},{"location":"5_6_formularios_flask_wtf.html#creando-formularios","text":"En el directorio de nuestra aplicaci\u00f3n (aplicacion) vamos a crear un fichero (forms.py) donde vamos a guardar los distintos formularios de nuestra aplicaci\u00f3n. Por ejemplo el fichero forms.py:","title":"Creando formularios"},{"location":"5_6_formularios_flask_wtf.html#trabajando-con-formularios","text":"En nuestra aplicaci\u00f3n app.py tenemos que importar la clase que hemos creado: from aplicacion.forms import formcalculadora Y a continuaci\u00f3n podemos crear un objeto a partir de ella: form = formcalculadora() Al crear el formulario podemos inicialzarlos con datos, normalmente con los par\u00e1metros recibidos en la vista (request.form): form = formcalculadora(request.form) El objeto form nos ofrece algunos atributos y m\u00e9todos para su gesti\u00f3n: form.validate_on_submit(): Nos permite comprobar si el formulario ha sido enviado y es v\u00e1lido. form.data: Nos ofrece un diccionario con los datos del formulario. form.errors: Si el formulario no es v\u00e1lido nos devuelve un diccionario con los errores. form.num1.data: Para cada campo (en este ejemplo num1)`nos devuelve su valor. form.num1.errors: Es una tupla con los errores de validaci\u00f3n de el campo determinado. form.num1(): Nos devuelve el c\u00f3digo HTML para generar este campo. form.num1.label(): Nos devuelve el c\u00f3digo HTML para general la etiqueta del campo. Puedes encontrar m\u00e1s atributos y m\u00e9todos en la documentaci\u00f3n de WTForm .","title":"Trabajando con formularios"},{"location":"5_6_formularios_flask_wtf.html#seguridad-en-los-formularios","text":"Por defecto Flask-WTF protege los formularios contra el ataque CSRF (Cross-Site Request Forgery o falsificaci\u00f3n de petici\u00f3n en sitios cruzados). Este ataque se produce cuando un sitio web malicioso env\u00eda solicitudes a un sitio web en el que est\u00e1 conectada la v\u00edctima. Para implementar la protecci\u00f3n CSRF, Flask-WTF necesita que configuremos una clave de cifrado, para generar tokens encriptados que se utilizar\u00e1n para verificar la autenticidad de la petici\u00f3n. Para ello, en nuestro programa principal: app.secret_key = 'clave de cifrado lo m\u00e1s robusta posible' Cada vez que generemos un formulario se incluir\u00e1 un campo oculto que contendr\u00e1 el token cifrado que permitir\u00e1 verificar que el envi\u00f3 del formulario ha sido l\u00edcita. Para generar este campo oculto utilizamos el m\u00e9todo form.csrf_token() que mostrar\u00e1 un c\u00f3digo HTML parecido a este: <input id=\"csrf_token\" name=\"csrf_token\" type=\"hidden\" value=\"IjE5OWRiYmY0MGE2MT...\">","title":"Seguridad en los formularios"},{"location":"5_6_formularios_flask_wtf.html#generacion-de-formularios","text":"En nuestra plantillas, podemos generar el formulario campo por campo, por ejemplo: <form action={{url_for(\"calculadora_post\")}} method=\"post\"> {{ form.csrf_token }} {{form.num1.label() }}{{form.num1()}}<br/> {{form.num2.label() }}{{form.num2()}}<br/> {{form.operador.label() }}{{form.operador()}}<br/> <br/> {{form.submit()}} </form> Tambi\u00e9n tenemos la opci\u00f3n de recorrer el formulario: <form action={{url_for(\"calculadora_post\")}} method=\"post\"> {% for field in form %} {{field.label() }}{{field()}}<br/> {% endfor %} </form> Para mostrar los errores de validaci\u00f3n podemos realizar un recorrido similar a este: {% for field, errors in form.errors.items() %} <div class=\"alert alert-danger\"> {{ form[field].label }}: {{ ', '.join(errors) }} </div> {% endfor %} Quedando el template/calculadora_post.html de la siguiente forma:","title":"Generaci\u00f3n de formularios"},{"location":"5_6_formularios_flask_wtf.html#enviando-y-gestionando-la-informacion-del-formulario","text":"Vamos a usar un patr\u00f3n de dise\u00f1o basado en la creaci\u00f3n de una vista que se comporte de la siguiente manera: La primera vez que accedemos a la ruta accedemos utilizando el m\u00e9todo GET. En nuestro caso se crear\u00e1 un formulario sin datos (ya que request.form no tiene ning\u00fan dato) , el formulario no se ha enviado y por lo tanto se devuelve la plantilla con el formulario vac\u00edo. Se rellena el formulario y se manda la informaci\u00f3n a la misma ruta pero utilizando el m\u00e9todo POST. En este caso se crea un formulario que se rellena con la informaci\u00f3n que se ha recibido del formulario. Si el formulario es v\u00e1lido se gestiona la informaci\u00f3n y se realiza la acci\u00f3n que se tenga que hacer (guardar en una base de datos, mostrar una plantilla resultado,\u2026) Si el formulario no es v\u00e1lido se vuelve a generar la plantilla con el formulario con datos, mostrando si lo hemos codificado los errores de validaci\u00f3n oportunos. En nuestro caso la llamada a la vista que hemos puesto en nuestro ejemplo de la calculadora quedar\u00eda de la siguiente manera:","title":"Enviando y gestionando la informaci\u00f3n del formulario"},{"location":"5_6_formularios_flask_wtf.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"5_7_subida_ficheros.html","text":"Subida de ficheros \u00b6 Es posible realizar subidas de ficheros al servidor, Flask nos ofrece est\u00e1 posibilidad, pero vamos a utilizar la extensi\u00f3n Flask-WTF para facilitar esta labor. Hay que recordad que cuando se manda un fichero al servidor la informaci\u00f3n del fichero la encontramos en request.file. En esta unidad vamos a hacer una aplicaci\u00f3n web que nos permita generar una galer\u00eda de im\u00e1genes. En nuestra galer\u00eda vamos a poder subir im\u00e1genes a trav\u00e9s de un formulario. Creando un formulario para subir ficheros \u00b6 Vamos a utilizar el tipo de campo FileField para crear nuestro formulario para subir un fichero. forms.py \u00b6 from flask_wtf import FlaskForm from wtforms import SubmitField from flask_wtf.file import FileField, FileRequired class UploadForm(FlaskForm): photo = FileField('selecciona imagen:', validators=[FileRequired()]) submit = SubmitField('Submit') Adem\u00e1s hemos introducido una validaci\u00f3n, indicando que es necesario indicar un fichero. Generando el formulario \u00b6 De forma similar a lo que vimos en la unidad anterior vamos a generar el formulario en nuestra plantilla: template/upload.html \u00b6 {% extends \"base.html\" %} {% block title %}Prueba{% endblock %} {% block contenido %} <h2>Subir im\u00e1gnes</h2> {% for field, errors in form.errors.items() %} <div class=\"alert alert-danger\"> {{ form[field].label }}: {{ ', '.join(errors) }} </div> {% endfor %} <form action=\"{{url_for('upload')}}\" method=\"POST\" enctype=\"multipart/form-data\"> {{ form.csrf_token }} {{form.photo.label() }}{{form.photo()}}<br/> <br/> {{form.submit()}} </form> {% endblock %} Al subir un fichero es necesario poner el atributo enctype=\"multipart/form-data\" al definir el formulario. Tratamiento del fichero subido \u00b6 Al crear la vista vamos a crear un formulario: form = UploadForm() Al construir el objeto formulario no hemos indicado con que valores vamos a rellenar el formulario (en la unidad anterior lo indic\u00e1bamos de esta manera: form = UploadForm(request.form)). Cuando creamos un objeto de esta manera, autom\u00e1ticamente carga el formulario con los datos (request.form) y con los posibles ficheros que hayamos subido (request.file), por lo que tenemos a nuestra disposici\u00f3n los datos y los ficheros recibidos. Si el formulario es v\u00e1lido: Creamos un objeto fichero a parir del formulario f = form.photo.data Creamos un nombre de fichero que sea compatible con el sistema de archivo (lo hacemos con la funci\u00f3n secure_filename) filename = secure_filename(f.filename) Y lo guardamos en el directorio adecuado. f.save(app.root_path+\"/static/img/\"+filename) Finalmente realizamos una redirecci\u00f3n al inicio de la p\u00e1gina. return redirect(url_for('inicio')) La vista completa quedar\u00eda de la siguiente manera: app.py \u00b6 from flask import Flask, render_template, request, redirect, url_for from flask_bootstrap import Bootstrap from os import listdir from aplicacion.forms import UploadForm from werkzeug.utils import secure_filename app = Flask(__name__) app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT' Bootstrap(app) # Con esto listamos las im\u00e1genes @app.route('/') def inicio(): lista = [] for file in listdir(app.root_path+\"/static/img\"): lista.append(file) return render_template(\"inicio.html\", lista=lista) @app.route('/upload', methods=['get', 'post']) def upload(): form = UploadForm() # carga request.from y request.file if form.validate_on_submit(): f = form.photo.data filename = secure_filename(f.filename) f.save(app.root_path + \"/static/img/\" + filename) return redirect(url_for('inicio')) return render_template('upload.html', form=form) @app.errorhandler(404) def page_not_found(error): return render_template(\"error.html\", error=\"P\u00e1gina no encontrada...\"), 404 Vista inicio.html \u00b6 Si nos damos cuenta, no tenemos creada la vista inicial, esta en realidad es bastante simple, recorremos la lista que nos pasa y vamos mostrando cada una de las im\u00e1genes. template/inicio.html \u00b6 {% extends \"base.html\" %} {% block title %}Prueba{% endblock %} {% block contenido %} <h2>Geleria de im\u00e1genes</h2> {% for lis in lista %} <img src=\"{{url_for('static',filename='img/')}}{{lis}}\"/> {% endfor %} <br/> <a href=\"{{url_for('upload')}}\">Subir imagen</a> <br/> {% endblock %} C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"5.7. Subida de Ficheros"},{"location":"5_7_subida_ficheros.html#subida-de-ficheros","text":"Es posible realizar subidas de ficheros al servidor, Flask nos ofrece est\u00e1 posibilidad, pero vamos a utilizar la extensi\u00f3n Flask-WTF para facilitar esta labor. Hay que recordad que cuando se manda un fichero al servidor la informaci\u00f3n del fichero la encontramos en request.file. En esta unidad vamos a hacer una aplicaci\u00f3n web que nos permita generar una galer\u00eda de im\u00e1genes. En nuestra galer\u00eda vamos a poder subir im\u00e1genes a trav\u00e9s de un formulario.","title":"Subida de ficheros"},{"location":"5_7_subida_ficheros.html#creando-un-formulario-para-subir-ficheros","text":"Vamos a utilizar el tipo de campo FileField para crear nuestro formulario para subir un fichero.","title":"Creando un formulario para subir ficheros"},{"location":"5_7_subida_ficheros.html#generando-el-formulario","text":"De forma similar a lo que vimos en la unidad anterior vamos a generar el formulario en nuestra plantilla:","title":"Generando el formulario"},{"location":"5_7_subida_ficheros.html#tratamiento-del-fichero-subido","text":"Al crear la vista vamos a crear un formulario: form = UploadForm() Al construir el objeto formulario no hemos indicado con que valores vamos a rellenar el formulario (en la unidad anterior lo indic\u00e1bamos de esta manera: form = UploadForm(request.form)). Cuando creamos un objeto de esta manera, autom\u00e1ticamente carga el formulario con los datos (request.form) y con los posibles ficheros que hayamos subido (request.file), por lo que tenemos a nuestra disposici\u00f3n los datos y los ficheros recibidos. Si el formulario es v\u00e1lido: Creamos un objeto fichero a parir del formulario f = form.photo.data Creamos un nombre de fichero que sea compatible con el sistema de archivo (lo hacemos con la funci\u00f3n secure_filename) filename = secure_filename(f.filename) Y lo guardamos en el directorio adecuado. f.save(app.root_path+\"/static/img/\"+filename) Finalmente realizamos una redirecci\u00f3n al inicio de la p\u00e1gina. return redirect(url_for('inicio')) La vista completa quedar\u00eda de la siguiente manera:","title":"Tratamiento del fichero subido"},{"location":"5_7_subida_ficheros.html#vista-iniciohtml","text":"Si nos damos cuenta, no tenemos creada la vista inicial, esta en realidad es bastante simple, recorremos la lista que nos pasa y vamos mostrando cada una de las im\u00e1genes.","title":"Vista inicio.html"},{"location":"5_7_subida_ficheros.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"6_1_flask_sqlalchemy.html","text":"Usando base de datos en Flask, flask-sqlalchemy \u00b6 Aunque python nos ofrece diferentes m\u00f3dulos para conectarnos a los distintos motores de base de datos: mysql: MySql-Python , PyMySQL , Mysql Conector postgreSQL sqlite3 Usaremos la extensi\u00f3n Flask-SQLAlchemy para manejar el modelo de datos de nuestra aplicaci\u00f3n. Esta extensi\u00f3n provee un wrapper para el proyecto SQLAlchemy , el cual es un Object Relational Mapper o ORM . Los ORM permiten a las aplicaciones con base de datos trabajar con objetos en vez de tablas y SQL. Las operaciones realizadas en los objetos son traducidos a comandos de base de datos transparente para el ORM. Por lo tanto se abstrae el gestor de base de datos utilizado, si cambiamos de SGBD no tendremos que cambiar nuestra aplicaci\u00f3n. De este modo, por ejemplo, podemos estar trabajando con sqlite3 en nuestro entorno de desarrollo, y con una base de datos PostgreSQL en nuestro entorno de producci\u00f3n. Nuestra aplicaci\u00f3n: \u201cMini\u201d tienda virtual \u00b6 A partir de esta unidad vamos a desarrollar una aplicaci\u00f3n Web con todos los elementos que hemos aprendido en las unidades anteriores, las caracter\u00edsticas de nuestra aplicaci\u00f3n van a ser las siguientes: Vamos a crear una \u201cmini\u201d tienda virtual donde se van a vender art\u00edculos (en nuestro ejemplo ser\u00e1n videojuegos). Cada art\u00edculo pertenece a una categor\u00eda. A nuestra tienda virtual se pueden dar de alta nuestro clientes. Existe un usuario administrador que puede dar de alta, modificar o eliminar los art\u00edculos de la tienda. Cuando un usuario compra un art\u00edculo se guarda en un \u201ccarro de la compra\u201d. El carro de la compra no lo vamos a guardar en una tabla de la base de datos, vamos a utilizar cookies para guardar dicha informaci\u00f3n. Los usuarios pueden acceder a la tienda para realizar las compras, vamos a utilizar sesiones para similar la persistencia de la conexi\u00f3n. El modelo de base de datos \u00b6 Los datos que guardamos en nuestra base de datos ser\u00e1n representados por una colecci\u00f3n de clases que son referidas como modelos de base de datos. La capa ORM har\u00e1 las traducciones necesarias y convertir\u00e1 los objetos creados a partir de estas clases a filas en la base de datos. Veamos el modelo de datos que vamos a implementar: Categor\u00edas: Tabla para guardar las categor\u00edas de los art\u00edculo. Vamos a poder buscar art\u00edculos por categor\u00edas. Art\u00edculos: Tabla donde guardamos delos datos de los art\u00edculo. Cada art\u00edculo corresponde a una categor\u00eda. Usuarios: Tabla donde guardamos los datos de los usuarios. Un usuario puede tener el perfil de administrador. Carrito: Podr\u00edamos guardarlo en una tabla, pero en nuestro ejemplo vamos a usar cookies para gestionar los art\u00edculos que va comprando un usuario. Instalaci\u00f3n de flask-sqlalchemy \u00b6 La extensi\u00f3n Flask-sqlalchemy nos posibilita usar el m\u00f3dulo sqlalchemy en nuestra aplicaci\u00f3n FLask. Para instalarla, en nuestro entono virtual activo: pip install Flask-Sqlalchemy Recuerda que tambi\u00e9n puedes instalar las depencias con pip install -r requirements.txt A continuaci\u00f3n necesitamos configurar algunos par\u00e1metros para configurar nuestra aplicaci\u00f3n. Configuraci\u00f3n de nuestra configuraci\u00f3n \u00b6 Todos los par\u00e1metros de configuraci\u00f3n de la aplicaci\u00f3n que necesitemos los vamos a guardar en un nuevo fichero (config.py) que guardaremos en el directorio aplicacion, con la configuraci\u00f3n de Flask-sqlalchemy quedar\u00eda de la siguiente manera: config.py \u00b6 import os secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT' PWD = os.path.abspath(os.curdir) DEBUG = True SQLALCHEMY_DATABASE_URI = 'sqlite:///{}/dbase.db'.format(PWD) # con mysql, SQLALCHEMY_DATABASE_URI=mysql://username:password@server/db # SQLALCHEMY_DATABASE_URI = mysql://root:\"\"@localhost/db SQLALCHEMY_TRACK_MODIFICATIONS = False - secret_key: Ya la hab\u00edamos usado anteriormente, nos permite cifrar los tokens para el mecanismo de seguridad CSRF de los fomularios. - SQLALCHEMY_DATABASE_URI: Indicamos la cadena de conexi\u00f3n a la base de datos. En este caso vamos a utilizar una base de datos sqlite3. Podr\u00edamos tener varias variables para configurar las conexiones de base de datos en los entornos de desarrollo, prueba y producci\u00f3n. - SQLALCHEMY_TRACK_MODIFICATIONS: Deshabilitamos la gesti\u00f3n de notificaciones de sqlalchemy. Este fichero se utilizar\u00e1 en el programa principal ( app.py ) para cargar las variables de configuraci\u00f3n: app.config.from_object(config) Adem\u00e1s en el programa principal vamos a crear un objeto que representa nuestra base de datos: db = SQLAlchemy(app) El programa principal quedar\u00eda: app.py \u00b6 from flask import Flask, render_template from flask_bootstrap import Bootstrap from flask_sqlalchemy import SQLAlchemy from aplicacion import config app = Flask(__name__) app.config.from_object(config) Bootstrap(app) db = SQLAlchemy(app) @app.route('/') def inicio(): return render_template(\"inicio.html\") @app.errorhandler(404) def page_not_found(error): return render_template(\"error.html\",error=\"P\u00e1gina no encontrada...\"), 404 C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"6.1 Usando base de datos en Flask, flask-sqlalchemy"},{"location":"6_1_flask_sqlalchemy.html#usando-base-de-datos-en-flask-flask-sqlalchemy","text":"Aunque python nos ofrece diferentes m\u00f3dulos para conectarnos a los distintos motores de base de datos: mysql: MySql-Python , PyMySQL , Mysql Conector postgreSQL sqlite3 Usaremos la extensi\u00f3n Flask-SQLAlchemy para manejar el modelo de datos de nuestra aplicaci\u00f3n. Esta extensi\u00f3n provee un wrapper para el proyecto SQLAlchemy , el cual es un Object Relational Mapper o ORM . Los ORM permiten a las aplicaciones con base de datos trabajar con objetos en vez de tablas y SQL. Las operaciones realizadas en los objetos son traducidos a comandos de base de datos transparente para el ORM. Por lo tanto se abstrae el gestor de base de datos utilizado, si cambiamos de SGBD no tendremos que cambiar nuestra aplicaci\u00f3n. De este modo, por ejemplo, podemos estar trabajando con sqlite3 en nuestro entorno de desarrollo, y con una base de datos PostgreSQL en nuestro entorno de producci\u00f3n.","title":"Usando base de datos en Flask, flask-sqlalchemy"},{"location":"6_1_flask_sqlalchemy.html#nuestra-aplicacion-mini-tienda-virtual","text":"A partir de esta unidad vamos a desarrollar una aplicaci\u00f3n Web con todos los elementos que hemos aprendido en las unidades anteriores, las caracter\u00edsticas de nuestra aplicaci\u00f3n van a ser las siguientes: Vamos a crear una \u201cmini\u201d tienda virtual donde se van a vender art\u00edculos (en nuestro ejemplo ser\u00e1n videojuegos). Cada art\u00edculo pertenece a una categor\u00eda. A nuestra tienda virtual se pueden dar de alta nuestro clientes. Existe un usuario administrador que puede dar de alta, modificar o eliminar los art\u00edculos de la tienda. Cuando un usuario compra un art\u00edculo se guarda en un \u201ccarro de la compra\u201d. El carro de la compra no lo vamos a guardar en una tabla de la base de datos, vamos a utilizar cookies para guardar dicha informaci\u00f3n. Los usuarios pueden acceder a la tienda para realizar las compras, vamos a utilizar sesiones para similar la persistencia de la conexi\u00f3n.","title":"Nuestra aplicaci\u00f3n: \u201cMini\u201d tienda virtual"},{"location":"6_1_flask_sqlalchemy.html#el-modelo-de-base-de-datos","text":"Los datos que guardamos en nuestra base de datos ser\u00e1n representados por una colecci\u00f3n de clases que son referidas como modelos de base de datos. La capa ORM har\u00e1 las traducciones necesarias y convertir\u00e1 los objetos creados a partir de estas clases a filas en la base de datos. Veamos el modelo de datos que vamos a implementar: Categor\u00edas: Tabla para guardar las categor\u00edas de los art\u00edculo. Vamos a poder buscar art\u00edculos por categor\u00edas. Art\u00edculos: Tabla donde guardamos delos datos de los art\u00edculo. Cada art\u00edculo corresponde a una categor\u00eda. Usuarios: Tabla donde guardamos los datos de los usuarios. Un usuario puede tener el perfil de administrador. Carrito: Podr\u00edamos guardarlo en una tabla, pero en nuestro ejemplo vamos a usar cookies para gestionar los art\u00edculos que va comprando un usuario.","title":"El modelo de base de datos"},{"location":"6_1_flask_sqlalchemy.html#instalacion-de-flask-sqlalchemy","text":"La extensi\u00f3n Flask-sqlalchemy nos posibilita usar el m\u00f3dulo sqlalchemy en nuestra aplicaci\u00f3n FLask. Para instalarla, en nuestro entono virtual activo: pip install Flask-Sqlalchemy Recuerda que tambi\u00e9n puedes instalar las depencias con pip install -r requirements.txt A continuaci\u00f3n necesitamos configurar algunos par\u00e1metros para configurar nuestra aplicaci\u00f3n.","title":"Instalaci\u00f3n de flask-sqlalchemy"},{"location":"6_1_flask_sqlalchemy.html#configuracion-de-nuestra-configuracion","text":"Todos los par\u00e1metros de configuraci\u00f3n de la aplicaci\u00f3n que necesitemos los vamos a guardar en un nuevo fichero (config.py) que guardaremos en el directorio aplicacion, con la configuraci\u00f3n de Flask-sqlalchemy quedar\u00eda de la siguiente manera:","title":"Configuraci\u00f3n de nuestra configuraci\u00f3n"},{"location":"6_1_flask_sqlalchemy.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"6_2_modelos_BBDD.html","text":"El modelo de base de datos \u00b6 Los datos que guardamos en nuestra base de datos ser\u00e1n representados por una colecci\u00f3n de clases que son referidas como modelos de base de datos. Definici\u00f3n del modelo \u00b6 En nuestro proyecto vamos a definir el modelo en el fichero models.py que crearemos dentro del directorio de nuestra aplicaci\u00f3n ( aplicacion ). Veamos, por ejemplo, el modelo de la tabla de Articulos : from sqlalchemy import Boolean, Column , ForeignKey from sqlalchemy import DateTime, Integer, String, Text, Float from sqlalchemy.orm import relationship from aplicacion.app import db ... class Articulos(db.Model): \"\"\"Art\u00edculos de nuestra tienda\"\"\" __tablename__ = 'articulos' id = Column(Integer, primary_key=True) nombre = Column(String(100),nullable=False) precio = Column(Float,default=0) iva = Column(Integer,default=21) descripcion = Column(String(255)) image = Column(String(255)) stock = Column(Integer,default=0) CategoriaId=Column(Integer,ForeignKey('categorias.id'), nullable=False) categoria = relationship(\"Categorias\", backref=\"Articulos\") def precio_final(self): return self.precio*self.iva/100 def __repr__(self): return (u'<{self.__class__.__name__}: {self.id}>'.format(self=self)) Podemos indicar varias cosas importantes: Hemos importado el objeto db del m\u00f3dulo principal: from aplicacion.app import db En la variable __tablename__ indicamos el nombre de la tabla a la que corresponde esta clase. Vamos indicando los distintos campos del modelo utilizando el constructor db.Column e indicando el tipo de datos que van a guardar. Podemos indicar los siguientes tipos de datos . Adem\u00e1s del tipo de datos podemos indicar los atributos de cada campo ( primary_key , unique , ForeignKey ,...) Hemos indicado una relaci\u00f3n con el constructor relationship , esto nos permite relacionar objetos de una clase (registros de una tabla) con los objetos de otra clase que est\u00e1n relacionados. En nuestro caso es una relaci\u00f3n uno a uno entre un art\u00edculo y su categor\u00eda. (En el modelo de categor\u00eda puedes ver una relaci\u00f3n 1 a N, una categor\u00eda tiene varios art\u00edculos). Por \u00faltimo c\u00f3mo estamos creando una clase, podemos definir nuevos m\u00e9todos ( precio_final ) o reescribir los heredados de la clase madre ( repr ). Por cierto, faltar\u00eda el modelo de la tabla Categor\u00edas , pero este lo dejamos para el c\u00f3digo de la aplicaci\u00f3n. Jugando con el modelo \u00b6 Vamos a realizar distintas operaciones con nuestro modelo. Lo primero que hay que indicar que debemos importar antes el objeto db que representa la base de datos y posteriormente los modelos que vamos a usar: from aplicacion.app import db from aplicacion.models import Categorias,Articulos Creaci\u00f3n de las tablas \u00b6 Para crear las tablas en la base de datos: db.create_all() Est\u00e1 instrucci\u00f3n no actualiza la estructura de la base de datos si cambiamos el modelo, por lo tanto en esa circunstancia tenemos que borrar las tablas y crearlas de nuevo: db.drop_all() db.create_all() Podemos utilizar tambi\u00e9n la migraci\u00f3n de base de datos que me permite, al cambiar el modelo actualizar la estructura de la base de datos. Para trabajar con migraciones podemos usar la extensi\u00f3n Flask-Migrate A\u00f1adiendo registros a las tablas \u00b6 A continuaci\u00f3n vamos a a\u00f1adir una categor\u00eda: cat=Categorias(nombre=\"Arcade\") db.session.add(cat) db.session.commit() Y dos art\u00edculos de esa categor\u00eda: art1=Articulos(nombre=\"PAC-MAN\",precio=12,descripcion=\"juego de fantasmitas\",stock=1,CategoriaId=1) art2=Articulos(nombre=\"Super Mario Bros\",precio=25,descripcion=\"juego de platoformas\",stock=10,categoria=cat) db.session.add_all([art1,art2]) db.session.commit() Modificando registros \u00b6 Simplemente podemos cambiar el valor de una campo y volver a\u00f1adirlo: art1.precio=15 db.session.add(art1) db.session.commit() Borrando registros \u00b6 db.session.delete(art2) db.session.commit() Obteniendo registros \u00b6 Podemos realizar diferentes operaciones para obtener un conjunto de registros. Por ejemplo podemos obtener el primer registro: art=Articulos.query.first() O el registro cuyo identificador sea el 2: art=Articulos.query.get(2) O podemos obtener todos los art\u00edculos: articulos=Articulos.query.all() Cuando tenemos un registro (que corresponde a un objeto de nuestro modelo) podemos obtener el valor de cada uno de los campos: print(art.nombre) Por lo tanto podemos recorrer todos los registros para mostrar el nombre: for art in Articulos.query.all(): print (art.nombre) Para terminar podemos obtener el n\u00famero de registros: Articulos.query.count() Filtrando registros \u00b6 Podemos obtener los art\u00edculos que tienen un precio determinado: Articulos.query.filter_by(precio=25).all() Si quiero filtrar por dos campos: Articulos.query.filter_by(precio=25).filter_by(iva=21).all() Si quieres ordenar por un campo: Articulos.query.order_by(\"precio\").all() Trabajar con las relaciones \u00b6 A partir de un art\u00edculo puedo obtener los datos de la categor\u00eda: art1.categoria.nombre Y a partir de una categor\u00eda puedo obtener los art\u00edculos de la misma: for art in cat.articulos: print(art.nombre) Iniciando la base de datos con inicializacion_datos.py \u00b6 A partir de lo visto en el punto anterior vamos a crear el fichero inicializacion_datos.py . Este fichero lo vamos utilizar solamente para crear las tablas y generar los datos iniciales. Esto s\u00f3lo ser\u00eda necesario al principio de la aplicaci\u00f3n, para no empezar con una base de datos vac\u00eda. from aplicacion.app import db from aplicacion.models import Categorias, Articulos def create_tables(): #\"Create relational database tables.\" db.create_all() def drop_tables(): #\"Drop all project relational database tables. THIS DELETES DATA.\" db.drop_all() def add_data_tables(): db.create_all() categorias = (\"Deportes\", \"Arcade\", \"Carreras\", \"Acci\u00f3n\") for cat in categorias: categoria = Categorias(nombre=cat) db.session.add(categoria) db.session.commit() juegos = [ {\"nombre\": \"Fernando Mart\u00edn Basket\", \"precio\": 12, \"descripcion\": \"Fernando Mart\u00edn Basket Master es un videojuego de baloncesto, uno \" \"contra uno, publicado por Dinamic Software en 1987\", \"stock\": 10, \"CategoriaId\": 1}, {\"nombre\": \"Hyper Soccer\", \"precio\": 10, \"descripcion\": \"Konami Hyper \" \"Soccer fue el primer videojuego de f\u00fatbol de Konami para una consola\" \" Nintendo, y considerado la semilla de las posteriores sagas \" \"International Superstar Soccer y Winning Eleven.\", \"stock\": 7, \"CategoriaId\": 1}, {\"nombre\": \"Arkanoid\", \"precio\": 15, \"descripcion\": \"Arkanoid es un \" \"videojuego de arcade desarrollado por Taito en 1986. Est\u00e1 basado en \" \"los Breakout de Atari de los a\u00f1os 70.\", \"stock\": 1, \"CategoriaId\": 2}, {\"nombre\": \"Tetris\", \"precio\": 6, \"descripcion\": \"Tetris es un \" \"videojuego de puzzle originalmente dise\u00f1ado y programado por Aleks\u00e9i\" \" P\u00e1zhitnov en la Uni\u00f3n Sovi\u00e9tica.\", \"stock\": 5, \"CategoriaId\": 2}, {\"nombre\": \"Road Fighter\", \"precio\": 15, \"descripcion\": \"Road Fighter \" \"es un videojuego de carreras producido por Konami y lanzado en los \" \"arcades en 1984. Fue el primer juego de carreras desarrollado por \" \"esta compa\u00f1\u00eda.\", \"stock\": 10, \"CategoriaId\": 3}, {\"nombre\": \"Out Run\", \"precio\": 10, \"descripcion\": \"Out Run es un \" \"videojuego de carreras creado en 1986 por Y\u016b Suzuki y Sega-AM2, y \" \"publicado inicialmente para m\u00e1quinas recreativas.\", \"stock\": 3, \"CategoriaId\": 3}, {\"nombre\": \"Army Moves\", \"precio\": 8, \"descripcion\": \"Army Moves es un\" \" arcade y primera parte de la trilog\u00eda Moves dise\u00f1ado por V\u00edctor \" \"Ruiz, de Dinamic Software para Commodore Amiga, Amstrad CPC, Atari \" \"ST, Commodore 64, MSX y ZX Spectrum en 1986.\", \"stock\": 8, \"CategoriaId\": 4}, {\"nombre\": \"La Abadia del Crimen\", \"precio\": 4, \"descripcion\": \"La \" \"Abad\u00eda del Crimen es un videojuego desarrollado inicialmente de \" \"forma freelance y publicado por la Academia Mister Chip en noviembre\" \" de 1987, posteriormente se publica bajo el sello de Opera Soft ya \" \"entrado 1988.\", \"stock\": 10, \"CategoriaId\": 4}, ] for jue in juegos: juego = Articulos(**jue) db.session.add(juego) db.session.commit() Como se puede observar los primeras funciones s\u00f3lo sirven para crear o borrar las tablas. La m\u00e1s interesante ser\u00eda: db.create_all() categorias = (\"Deportes\", \"Arcade\", \"Carreras\", \"Acci\u00f3n\") for cat in categorias: categoria = Categorias(nombre=cat) db.session.add(categoria) db.session.commit() Recorremos la tupla categor\u00edas y vamos creando objetos del Modelo Categor\u00edas, como s\u00f3lo tiene como campo nombre y el id es autonum\u00e9ricos, s\u00f3lo le pasamos el nombre. En el caso de los juegos: for jue in juegos: juego = Articulos(**jue) db.session.add(juego) db.session.commit() Recorremos las lista y para cada diccionario con la informaci\u00f3n del juego lo introducimos en la base de datos. En este caso utilizamos **jue para indicar que le pasamos muchos datos. Uso del modelo en el programa principal \u00b6 En esta unidad hemos desarrollado una peque\u00f1a vista para mostrar los nombres de los art\u00edculos. En el fichero app.py tendr\u00edamos: ... app = Flask(__name__) app.config.from_object(config) Bootstrap(app) db = SQLAlchemy(app) #Importamos los modelos una vez existe una instancia de app y otra instancia de db, # En otras palabras si no hay base de datos, no puedo utilizar los modelos # no base de datos (objeto) => No puedo acceder a las tablas from aplicacion.models import * @app.route('/') def inicio(): #esto es para la primera vez, creo datos por defecto #luego comentar from aplicacion.inicializacion_datos import add_data_tables, drop_tables drop_tables() add_data_tables() articulos=Articulos.query.all() return render_template(\"inicio.html\",articulos=articulos) ... y la plantilla inicio.html quedar\u00eda: {% extends \"base.html\" %} {% block title %}Tienda de Videojuegos{% endblock %} {% block contenido %} <h3>Nuestros videojuegos...</h3> <div class=\"panel panel-default\"> <!-- Default panel contents --> <div class=\"panel-heading\">Videojuegos</div> <table class=\"table\"> {% for art in articulos %} <tr> <td>{{art.nombre}}</td> </tr> {% endfor %} </table> </div> </div> {% endblock %} C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"6.2 El modelo de base de datos"},{"location":"6_2_modelos_BBDD.html#el-modelo-de-base-de-datos","text":"Los datos que guardamos en nuestra base de datos ser\u00e1n representados por una colecci\u00f3n de clases que son referidas como modelos de base de datos.","title":"El modelo de base de datos"},{"location":"6_2_modelos_BBDD.html#definicion-del-modelo","text":"En nuestro proyecto vamos a definir el modelo en el fichero models.py que crearemos dentro del directorio de nuestra aplicaci\u00f3n ( aplicacion ). Veamos, por ejemplo, el modelo de la tabla de Articulos : from sqlalchemy import Boolean, Column , ForeignKey from sqlalchemy import DateTime, Integer, String, Text, Float from sqlalchemy.orm import relationship from aplicacion.app import db ... class Articulos(db.Model): \"\"\"Art\u00edculos de nuestra tienda\"\"\" __tablename__ = 'articulos' id = Column(Integer, primary_key=True) nombre = Column(String(100),nullable=False) precio = Column(Float,default=0) iva = Column(Integer,default=21) descripcion = Column(String(255)) image = Column(String(255)) stock = Column(Integer,default=0) CategoriaId=Column(Integer,ForeignKey('categorias.id'), nullable=False) categoria = relationship(\"Categorias\", backref=\"Articulos\") def precio_final(self): return self.precio*self.iva/100 def __repr__(self): return (u'<{self.__class__.__name__}: {self.id}>'.format(self=self)) Podemos indicar varias cosas importantes: Hemos importado el objeto db del m\u00f3dulo principal: from aplicacion.app import db En la variable __tablename__ indicamos el nombre de la tabla a la que corresponde esta clase. Vamos indicando los distintos campos del modelo utilizando el constructor db.Column e indicando el tipo de datos que van a guardar. Podemos indicar los siguientes tipos de datos . Adem\u00e1s del tipo de datos podemos indicar los atributos de cada campo ( primary_key , unique , ForeignKey ,...) Hemos indicado una relaci\u00f3n con el constructor relationship , esto nos permite relacionar objetos de una clase (registros de una tabla) con los objetos de otra clase que est\u00e1n relacionados. En nuestro caso es una relaci\u00f3n uno a uno entre un art\u00edculo y su categor\u00eda. (En el modelo de categor\u00eda puedes ver una relaci\u00f3n 1 a N, una categor\u00eda tiene varios art\u00edculos). Por \u00faltimo c\u00f3mo estamos creando una clase, podemos definir nuevos m\u00e9todos ( precio_final ) o reescribir los heredados de la clase madre ( repr ). Por cierto, faltar\u00eda el modelo de la tabla Categor\u00edas , pero este lo dejamos para el c\u00f3digo de la aplicaci\u00f3n.","title":"Definici\u00f3n del modelo"},{"location":"6_2_modelos_BBDD.html#jugando-con-el-modelo","text":"Vamos a realizar distintas operaciones con nuestro modelo. Lo primero que hay que indicar que debemos importar antes el objeto db que representa la base de datos y posteriormente los modelos que vamos a usar: from aplicacion.app import db from aplicacion.models import Categorias,Articulos","title":"Jugando con el modelo"},{"location":"6_2_modelos_BBDD.html#creacion-de-las-tablas","text":"Para crear las tablas en la base de datos: db.create_all() Est\u00e1 instrucci\u00f3n no actualiza la estructura de la base de datos si cambiamos el modelo, por lo tanto en esa circunstancia tenemos que borrar las tablas y crearlas de nuevo: db.drop_all() db.create_all() Podemos utilizar tambi\u00e9n la migraci\u00f3n de base de datos que me permite, al cambiar el modelo actualizar la estructura de la base de datos. Para trabajar con migraciones podemos usar la extensi\u00f3n Flask-Migrate","title":"Creaci\u00f3n de las tablas"},{"location":"6_2_modelos_BBDD.html#anadiendo-registros-a-las-tablas","text":"A continuaci\u00f3n vamos a a\u00f1adir una categor\u00eda: cat=Categorias(nombre=\"Arcade\") db.session.add(cat) db.session.commit() Y dos art\u00edculos de esa categor\u00eda: art1=Articulos(nombre=\"PAC-MAN\",precio=12,descripcion=\"juego de fantasmitas\",stock=1,CategoriaId=1) art2=Articulos(nombre=\"Super Mario Bros\",precio=25,descripcion=\"juego de platoformas\",stock=10,categoria=cat) db.session.add_all([art1,art2]) db.session.commit()","title":"A\u00f1adiendo registros a las tablas"},{"location":"6_2_modelos_BBDD.html#modificando-registros","text":"Simplemente podemos cambiar el valor de una campo y volver a\u00f1adirlo: art1.precio=15 db.session.add(art1) db.session.commit()","title":"Modificando registros"},{"location":"6_2_modelos_BBDD.html#borrando-registros","text":"db.session.delete(art2) db.session.commit()","title":"Borrando registros"},{"location":"6_2_modelos_BBDD.html#obteniendo-registros","text":"Podemos realizar diferentes operaciones para obtener un conjunto de registros. Por ejemplo podemos obtener el primer registro: art=Articulos.query.first() O el registro cuyo identificador sea el 2: art=Articulos.query.get(2) O podemos obtener todos los art\u00edculos: articulos=Articulos.query.all() Cuando tenemos un registro (que corresponde a un objeto de nuestro modelo) podemos obtener el valor de cada uno de los campos: print(art.nombre) Por lo tanto podemos recorrer todos los registros para mostrar el nombre: for art in Articulos.query.all(): print (art.nombre) Para terminar podemos obtener el n\u00famero de registros: Articulos.query.count()","title":"Obteniendo registros"},{"location":"6_2_modelos_BBDD.html#filtrando-registros","text":"Podemos obtener los art\u00edculos que tienen un precio determinado: Articulos.query.filter_by(precio=25).all() Si quiero filtrar por dos campos: Articulos.query.filter_by(precio=25).filter_by(iva=21).all() Si quieres ordenar por un campo: Articulos.query.order_by(\"precio\").all()","title":"Filtrando registros"},{"location":"6_2_modelos_BBDD.html#trabajar-con-las-relaciones","text":"A partir de un art\u00edculo puedo obtener los datos de la categor\u00eda: art1.categoria.nombre Y a partir de una categor\u00eda puedo obtener los art\u00edculos de la misma: for art in cat.articulos: print(art.nombre)","title":"Trabajar con las relaciones"},{"location":"6_2_modelos_BBDD.html#iniciando-la-base-de-datos-con-inicializacion_datospy","text":"A partir de lo visto en el punto anterior vamos a crear el fichero inicializacion_datos.py . Este fichero lo vamos utilizar solamente para crear las tablas y generar los datos iniciales. Esto s\u00f3lo ser\u00eda necesario al principio de la aplicaci\u00f3n, para no empezar con una base de datos vac\u00eda. from aplicacion.app import db from aplicacion.models import Categorias, Articulos def create_tables(): #\"Create relational database tables.\" db.create_all() def drop_tables(): #\"Drop all project relational database tables. THIS DELETES DATA.\" db.drop_all() def add_data_tables(): db.create_all() categorias = (\"Deportes\", \"Arcade\", \"Carreras\", \"Acci\u00f3n\") for cat in categorias: categoria = Categorias(nombre=cat) db.session.add(categoria) db.session.commit() juegos = [ {\"nombre\": \"Fernando Mart\u00edn Basket\", \"precio\": 12, \"descripcion\": \"Fernando Mart\u00edn Basket Master es un videojuego de baloncesto, uno \" \"contra uno, publicado por Dinamic Software en 1987\", \"stock\": 10, \"CategoriaId\": 1}, {\"nombre\": \"Hyper Soccer\", \"precio\": 10, \"descripcion\": \"Konami Hyper \" \"Soccer fue el primer videojuego de f\u00fatbol de Konami para una consola\" \" Nintendo, y considerado la semilla de las posteriores sagas \" \"International Superstar Soccer y Winning Eleven.\", \"stock\": 7, \"CategoriaId\": 1}, {\"nombre\": \"Arkanoid\", \"precio\": 15, \"descripcion\": \"Arkanoid es un \" \"videojuego de arcade desarrollado por Taito en 1986. Est\u00e1 basado en \" \"los Breakout de Atari de los a\u00f1os 70.\", \"stock\": 1, \"CategoriaId\": 2}, {\"nombre\": \"Tetris\", \"precio\": 6, \"descripcion\": \"Tetris es un \" \"videojuego de puzzle originalmente dise\u00f1ado y programado por Aleks\u00e9i\" \" P\u00e1zhitnov en la Uni\u00f3n Sovi\u00e9tica.\", \"stock\": 5, \"CategoriaId\": 2}, {\"nombre\": \"Road Fighter\", \"precio\": 15, \"descripcion\": \"Road Fighter \" \"es un videojuego de carreras producido por Konami y lanzado en los \" \"arcades en 1984. Fue el primer juego de carreras desarrollado por \" \"esta compa\u00f1\u00eda.\", \"stock\": 10, \"CategoriaId\": 3}, {\"nombre\": \"Out Run\", \"precio\": 10, \"descripcion\": \"Out Run es un \" \"videojuego de carreras creado en 1986 por Y\u016b Suzuki y Sega-AM2, y \" \"publicado inicialmente para m\u00e1quinas recreativas.\", \"stock\": 3, \"CategoriaId\": 3}, {\"nombre\": \"Army Moves\", \"precio\": 8, \"descripcion\": \"Army Moves es un\" \" arcade y primera parte de la trilog\u00eda Moves dise\u00f1ado por V\u00edctor \" \"Ruiz, de Dinamic Software para Commodore Amiga, Amstrad CPC, Atari \" \"ST, Commodore 64, MSX y ZX Spectrum en 1986.\", \"stock\": 8, \"CategoriaId\": 4}, {\"nombre\": \"La Abadia del Crimen\", \"precio\": 4, \"descripcion\": \"La \" \"Abad\u00eda del Crimen es un videojuego desarrollado inicialmente de \" \"forma freelance y publicado por la Academia Mister Chip en noviembre\" \" de 1987, posteriormente se publica bajo el sello de Opera Soft ya \" \"entrado 1988.\", \"stock\": 10, \"CategoriaId\": 4}, ] for jue in juegos: juego = Articulos(**jue) db.session.add(juego) db.session.commit() Como se puede observar los primeras funciones s\u00f3lo sirven para crear o borrar las tablas. La m\u00e1s interesante ser\u00eda: db.create_all() categorias = (\"Deportes\", \"Arcade\", \"Carreras\", \"Acci\u00f3n\") for cat in categorias: categoria = Categorias(nombre=cat) db.session.add(categoria) db.session.commit() Recorremos la tupla categor\u00edas y vamos creando objetos del Modelo Categor\u00edas, como s\u00f3lo tiene como campo nombre y el id es autonum\u00e9ricos, s\u00f3lo le pasamos el nombre. En el caso de los juegos: for jue in juegos: juego = Articulos(**jue) db.session.add(juego) db.session.commit() Recorremos las lista y para cada diccionario con la informaci\u00f3n del juego lo introducimos en la base de datos. En este caso utilizamos **jue para indicar que le pasamos muchos datos.","title":"Iniciando la base de datos con inicializacion_datos.py"},{"location":"6_2_modelos_BBDD.html#uso-del-modelo-en-el-programa-principal","text":"En esta unidad hemos desarrollado una peque\u00f1a vista para mostrar los nombres de los art\u00edculos. En el fichero app.py tendr\u00edamos: ... app = Flask(__name__) app.config.from_object(config) Bootstrap(app) db = SQLAlchemy(app) #Importamos los modelos una vez existe una instancia de app y otra instancia de db, # En otras palabras si no hay base de datos, no puedo utilizar los modelos # no base de datos (objeto) => No puedo acceder a las tablas from aplicacion.models import * @app.route('/') def inicio(): #esto es para la primera vez, creo datos por defecto #luego comentar from aplicacion.inicializacion_datos import add_data_tables, drop_tables drop_tables() add_data_tables() articulos=Articulos.query.all() return render_template(\"inicio.html\",articulos=articulos) ... y la plantilla inicio.html quedar\u00eda: {% extends \"base.html\" %} {% block title %}Tienda de Videojuegos{% endblock %} {% block contenido %} <h3>Nuestros videojuegos...</h3> <div class=\"panel panel-default\"> <!-- Default panel contents --> <div class=\"panel-heading\">Videojuegos</div> <table class=\"table\"> {% for art in articulos %} <tr> <td>{{art.nombre}}</td> </tr> {% endfor %} </table> </div> </div> {% endblock %}","title":"Uso del modelo en el programa principal"},{"location":"6_2_modelos_BBDD.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"6_3_listando_filtrando.html","text":"Listando y filtrando los registros de la base de datos \u00b6 En esta unidad vamos a seguir trabando en nuestro proyecto, vamos a listar los art\u00edculos y las categor\u00edas. Adem\u00e1s vamos a poder seleccionar los art\u00edculos por categor\u00eda. Seleccionando registros en el programa principal \u00b6 @app.route('/') @app.route('/categoria/<id>') def inicio(id='0'): categoria=Categorias.query.get(id) if id=='0': articulos=Articulos.query.all() else: articulos=Articulos.query.filter_by(CategoriaId=id) categorias=Categorias.query.all() return render_template(\"inicio.html\",articulos=articulos,categorias=categorias,categoria=categoria) Ejecutamos esta funci\u00f3n cuando accedemos a la p\u00e1gina (ruta / ) o cuando hemos seleccionado una determinada categoria (ruta categorida/<id> ): Si accedemos a la p\u00e1gina (ruta / ) el identificado de la categor\u00eda ser\u00e1 por defecto el 0, que corresponde a la categor\u00eda Todos . En este caso se seleccionaran todos los art\u00edculos. Si accedemos a la p\u00e1gina seleccionando una categor\u00eda, se mandar\u00e1 el identificador de la categor\u00eda y se seleccionar\u00e1n los videojuegos que tienen dicha categor\u00eda. En los dos casos se muestra una plantilla donde se muestran todas las categor\u00edas y los art\u00edculos seleccionados. Consideramos que la categor\u00eda 0:'Todos', debe existir al crear las tablas por lo tanto hemos modificado el fichero manage.py para crearla: @manager.command def create_tables(): \"Create relational database tables.\" db.create_all() categoria=Categorias(id=0,nombre=\"Todos\") db.session.add(categoria) db.session.commit() Plantilla para mostrar el listado: inicio.html \u00b6 Podemos diferenciar dos partes: En primer lugar mostramos las categor\u00edas, como hemos enviado el nombre de la categor\u00eda seleccionada, podemos se\u00f1alar la categor\u00eda por medio del CSS. {% for cat in categorias %} {% if categoria.nombre==cat.nombre%} <a class=\"list-group-item active\" href=\"{{url_for(\"inicio\",id=cat.id)}}\">{{cat.nombre}}</a> {% else %} <a class=\"list-group-item\" href=\"{{url_for(\"inicio\",id=cat.id)}}\">{{cat.nombre}}</a> {% endif%} {% endfor %} Podemos seleccionar una categor\u00eda para filtrar los art\u00edculos. Mostramos los art\u00edculos seleccionados: {% for art in articulos %} <tr> {% if art.image %} <td><img src=\"{{url_for('static',filename='upload/')}}{{art.image}}\"/> {% else %} <td><img src=\"{{url_for('static',filename='upload/not-found.png')}}\"/> {% endif %} <td>{{art.nombre}}</td> <td>{{art.descripcion}}</td> <td>{{art.precio_final()}}</td> <td><a href=\"#\"><span class=\"glyphicon glyphicon-shopping-cart\"></span> Comprar</a></td> </tr> {% endfor %} Mostramos los distintos campos de los art\u00edculos. Cada art\u00edculo tiene una imagen que podemos subir al darlo de alta. Si no hemos subido ninguna imagen se muestra una por defecto. Los im\u00e1genes se van a guardar en el directorio static/upload . Hemos incluido un enlace en el listado de art\u00edculos para realizar la comprar aunque todav\u00eda no lo vamos a usar. Listado de categor\u00edas \u00b6 Hemos creado una p\u00e1gina donde vamos a mostrar todas las categor\u00edas, para ello hemos incluido en enlace en la plantilla base.html : <a class=\"navbar-brand\" href=\"{{url_for('categorias')}}\">Categor\u00edas</a> En el programa principal: @app.route('/categorias') def categorias(): categorias=Categorias.query.all() return render_template(\"categorias.html\",categorias=categorias) Y la plantilla categorias.html : ... {% for cat in categorias %} <tr> <td>{{cat.nombre}}</td> </tr> {% endfor %} ... C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"6.3 Listando y filtrando los registros de la base de datos"},{"location":"6_3_listando_filtrando.html#listando-y-filtrando-los-registros-de-la-base-de-datos","text":"En esta unidad vamos a seguir trabando en nuestro proyecto, vamos a listar los art\u00edculos y las categor\u00edas. Adem\u00e1s vamos a poder seleccionar los art\u00edculos por categor\u00eda.","title":"Listando y filtrando los registros de la base de datos"},{"location":"6_3_listando_filtrando.html#seleccionando-registros-en-el-programa-principal","text":"@app.route('/') @app.route('/categoria/<id>') def inicio(id='0'): categoria=Categorias.query.get(id) if id=='0': articulos=Articulos.query.all() else: articulos=Articulos.query.filter_by(CategoriaId=id) categorias=Categorias.query.all() return render_template(\"inicio.html\",articulos=articulos,categorias=categorias,categoria=categoria) Ejecutamos esta funci\u00f3n cuando accedemos a la p\u00e1gina (ruta / ) o cuando hemos seleccionado una determinada categoria (ruta categorida/<id> ): Si accedemos a la p\u00e1gina (ruta / ) el identificado de la categor\u00eda ser\u00e1 por defecto el 0, que corresponde a la categor\u00eda Todos . En este caso se seleccionaran todos los art\u00edculos. Si accedemos a la p\u00e1gina seleccionando una categor\u00eda, se mandar\u00e1 el identificador de la categor\u00eda y se seleccionar\u00e1n los videojuegos que tienen dicha categor\u00eda. En los dos casos se muestra una plantilla donde se muestran todas las categor\u00edas y los art\u00edculos seleccionados. Consideramos que la categor\u00eda 0:'Todos', debe existir al crear las tablas por lo tanto hemos modificado el fichero manage.py para crearla: @manager.command def create_tables(): \"Create relational database tables.\" db.create_all() categoria=Categorias(id=0,nombre=\"Todos\") db.session.add(categoria) db.session.commit()","title":"Seleccionando registros en el programa principal"},{"location":"6_3_listando_filtrando.html#plantilla-para-mostrar-el-listado-iniciohtml","text":"Podemos diferenciar dos partes: En primer lugar mostramos las categor\u00edas, como hemos enviado el nombre de la categor\u00eda seleccionada, podemos se\u00f1alar la categor\u00eda por medio del CSS. {% for cat in categorias %} {% if categoria.nombre==cat.nombre%} <a class=\"list-group-item active\" href=\"{{url_for(\"inicio\",id=cat.id)}}\">{{cat.nombre}}</a> {% else %} <a class=\"list-group-item\" href=\"{{url_for(\"inicio\",id=cat.id)}}\">{{cat.nombre}}</a> {% endif%} {% endfor %} Podemos seleccionar una categor\u00eda para filtrar los art\u00edculos. Mostramos los art\u00edculos seleccionados: {% for art in articulos %} <tr> {% if art.image %} <td><img src=\"{{url_for('static',filename='upload/')}}{{art.image}}\"/> {% else %} <td><img src=\"{{url_for('static',filename='upload/not-found.png')}}\"/> {% endif %} <td>{{art.nombre}}</td> <td>{{art.descripcion}}</td> <td>{{art.precio_final()}}</td> <td><a href=\"#\"><span class=\"glyphicon glyphicon-shopping-cart\"></span> Comprar</a></td> </tr> {% endfor %} Mostramos los distintos campos de los art\u00edculos. Cada art\u00edculo tiene una imagen que podemos subir al darlo de alta. Si no hemos subido ninguna imagen se muestra una por defecto. Los im\u00e1genes se van a guardar en el directorio static/upload . Hemos incluido un enlace en el listado de art\u00edculos para realizar la comprar aunque todav\u00eda no lo vamos a usar.","title":"Plantilla para mostrar el listado: inicio.html"},{"location":"6_3_listando_filtrando.html#listado-de-categorias","text":"Hemos creado una p\u00e1gina donde vamos a mostrar todas las categor\u00edas, para ello hemos incluido en enlace en la plantilla base.html : <a class=\"navbar-brand\" href=\"{{url_for('categorias')}}\">Categor\u00edas</a> En el programa principal: @app.route('/categorias') def categorias(): categorias=Categorias.query.all() return render_template(\"categorias.html\",categorias=categorias) Y la plantilla categorias.html : ... {% for cat in categorias %} <tr> <td>{{cat.nombre}}</td> </tr> {% endfor %} ...","title":"Listado de categor\u00edas"},{"location":"6_3_listando_filtrando.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"6_4_creando.html","text":"Creando registros en la base de datos \u00b6 En este apartado vamos a estudiar como insertar un registro en nuestra base de datos. Creando nuevos art\u00edculos \u00b6 Lo primero es insertar un enlace en la p\u00e1gina principal que nos permita insertar nuevos art\u00edculos, para ello en la plantilla inicio.html : <a class=\"btn btn-primary\" href=\"{{url_for('articulos_new')}}\" role=\"button\">Nuevo videojuego</a> Para realizar nuestra operaci\u00f3n vamos a crear un formulario que nos permite introducir los datos del nuevo art\u00edculo, para ello en el fichero forms.py creamos una nueva clase formulario con la siguiente sintaxis: class formArticulo(FlaskForm): nombre=StringField(\"Nombre:\",validators=[Required(\"Tienes que introducir el dato\")]) precio=DecimalField(\"Precio:\",default=0,validators=[Required(\"Tienes que introducir el dato\")]) iva=IntegerField(\"IVA:\",default=21,validators=[Required(\"Tienes que introducir el dato\")]) descripcion= TextAreaField(\"Descripci\u00f3n:\") photo = FileField('Selecciona imagen:') stock=IntegerField(\"Stock:\",default=1,validators=[Required(\"Tienes que introducir el dato\")]) CategoriaId=SelectField(\"Categor\u00eda:\",coerce=int) submit = SubmitField('Enviar') Como novedad en el c\u00f3digoo anterior hemos utilizado el atributo coerce del objeto SelectField que indica el tipo de datos que va a devolver, en este caso un entero que es el \u00edndice de las categor\u00edas. En el programa principal hemos a\u00f1adido una nueva ruta para a\u00f1adir los nuevos art\u00edculos: @app.route('/articulos/new', methods=[\"get\",\"post\"]) def articulos_new(): form=formArticulo() categorias=[(c.id, c.nombre) for c in Categorias.query.all()[1:]] form.CategoriaId.choices = categorias if form.validate_on_submit(): try: f = form.photo.data nombre_fichero=secure_filename(f.filename) f.save(app.root_path+\"/static/upload/\"+nombre_fichero) except: nombre_fichero=\"\" art=Articulos() form.populate_obj(art) art.image=nombre_fichero db.session.add(art) db.session.commit() return redirect(url_for(\"inicio\")) else: return render_template(\"articulos_new.html\",form=form) Como hab\u00edamos visto en unidades anteriores: La primera vez que accedemos a la ruta accedemos utilizando el m\u00e9todo GET. En nuestro caso se crear\u00e1 un formulario sin datos (ya que request.form no tiene ning\u00fan dato) , el formulario no se ha enviado y por lo tanto se devuelve la plantilla con el formulario vac\u00edo. Se rellena el formulario y se manda la informaci\u00f3n a la misma ruta pero utilizando el m\u00e9todo POST. En este caso se crea un formulario que se rellena con la informaci\u00f3n que se ha recibido del formulario (en el que a\u00f1adimos la lista de categor\u00edas al campo categorias ). Si el formulario es v\u00e1lido se gestiona la informaci\u00f3n y se realiza las siguientes acciones: Se guarda el fichero que se ha subido el formulario. Se crea un nuevo objeto Articulos y se rellena con los datos del formulario ( form.populate_obj(art) ). Si el formulario no es v\u00e1lido se vuelve a generar la plantilla con el formulario con datos, mostrando si lo hemos codificado los errores de validaci\u00f3n oportunos. En la plantilla articulos_new.html puedes ver c\u00f3mo se ha generado la p\u00e1gina donde se muestra el formulario. Creando nuevas categor\u00edas \u00b6 De una forma similar puedes estudiar el c\u00f3digo para ver c\u00f3mo se a\u00f1aden nuevas categor\u00edas a nuestra base de datos. C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"6.4 Creando registros en la base de datos"},{"location":"6_4_creando.html#creando-registros-en-la-base-de-datos","text":"En este apartado vamos a estudiar como insertar un registro en nuestra base de datos.","title":"Creando registros en la base de datos"},{"location":"6_4_creando.html#creando-nuevos-articulos","text":"Lo primero es insertar un enlace en la p\u00e1gina principal que nos permita insertar nuevos art\u00edculos, para ello en la plantilla inicio.html : <a class=\"btn btn-primary\" href=\"{{url_for('articulos_new')}}\" role=\"button\">Nuevo videojuego</a> Para realizar nuestra operaci\u00f3n vamos a crear un formulario que nos permite introducir los datos del nuevo art\u00edculo, para ello en el fichero forms.py creamos una nueva clase formulario con la siguiente sintaxis: class formArticulo(FlaskForm): nombre=StringField(\"Nombre:\",validators=[Required(\"Tienes que introducir el dato\")]) precio=DecimalField(\"Precio:\",default=0,validators=[Required(\"Tienes que introducir el dato\")]) iva=IntegerField(\"IVA:\",default=21,validators=[Required(\"Tienes que introducir el dato\")]) descripcion= TextAreaField(\"Descripci\u00f3n:\") photo = FileField('Selecciona imagen:') stock=IntegerField(\"Stock:\",default=1,validators=[Required(\"Tienes que introducir el dato\")]) CategoriaId=SelectField(\"Categor\u00eda:\",coerce=int) submit = SubmitField('Enviar') Como novedad en el c\u00f3digoo anterior hemos utilizado el atributo coerce del objeto SelectField que indica el tipo de datos que va a devolver, en este caso un entero que es el \u00edndice de las categor\u00edas. En el programa principal hemos a\u00f1adido una nueva ruta para a\u00f1adir los nuevos art\u00edculos: @app.route('/articulos/new', methods=[\"get\",\"post\"]) def articulos_new(): form=formArticulo() categorias=[(c.id, c.nombre) for c in Categorias.query.all()[1:]] form.CategoriaId.choices = categorias if form.validate_on_submit(): try: f = form.photo.data nombre_fichero=secure_filename(f.filename) f.save(app.root_path+\"/static/upload/\"+nombre_fichero) except: nombre_fichero=\"\" art=Articulos() form.populate_obj(art) art.image=nombre_fichero db.session.add(art) db.session.commit() return redirect(url_for(\"inicio\")) else: return render_template(\"articulos_new.html\",form=form) Como hab\u00edamos visto en unidades anteriores: La primera vez que accedemos a la ruta accedemos utilizando el m\u00e9todo GET. En nuestro caso se crear\u00e1 un formulario sin datos (ya que request.form no tiene ning\u00fan dato) , el formulario no se ha enviado y por lo tanto se devuelve la plantilla con el formulario vac\u00edo. Se rellena el formulario y se manda la informaci\u00f3n a la misma ruta pero utilizando el m\u00e9todo POST. En este caso se crea un formulario que se rellena con la informaci\u00f3n que se ha recibido del formulario (en el que a\u00f1adimos la lista de categor\u00edas al campo categorias ). Si el formulario es v\u00e1lido se gestiona la informaci\u00f3n y se realiza las siguientes acciones: Se guarda el fichero que se ha subido el formulario. Se crea un nuevo objeto Articulos y se rellena con los datos del formulario ( form.populate_obj(art) ). Si el formulario no es v\u00e1lido se vuelve a generar la plantilla con el formulario con datos, mostrando si lo hemos codificado los errores de validaci\u00f3n oportunos. En la plantilla articulos_new.html puedes ver c\u00f3mo se ha generado la p\u00e1gina donde se muestra el formulario.","title":"Creando nuevos art\u00edculos"},{"location":"6_4_creando.html#creando-nuevas-categorias","text":"De una forma similar puedes estudiar el c\u00f3digo para ver c\u00f3mo se a\u00f1aden nuevas categor\u00edas a nuestra base de datos.","title":"Creando nuevas categor\u00edas"},{"location":"6_4_creando.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"6_5_modificando.html","text":"Modificando registros en la base de datos \u00b6 En este apartado vamos a estudiar como modificar un registro en nuestra base de datos. Modificando art\u00edculos \u00b6 Lo primero es insertar un enlace en la p\u00e1gina principal que nos permita modificar art\u00edculos (se a\u00f1ade un enlace por cada art\u00edculo), para ello en la plantilla inicio.html : <td><a href=\"{{url_for('articulos_edit',id=art.id)}}\"><span class=\"glyphicon glyphicon-pencil\"></span> Modificar</a></td> Vamos a usar el mismo formulario ( formArticulo ) que hemos utilizado en la unidad anterior para a\u00f1adir nuevos art\u00edculos, para realizar la modificaci\u00f3n. Vamos a utilizar el mismo template articulos_new.html para mostrar el formulario. En el programa principal, vamos a crear una ruta din\u00e1mica, que nos permite modificar un registro seg\u00fan su identificador: @app.route('/articulos/<id>/edit', methods=[\"get\",\"post\"]) Lo primero que hacemos es seleccionar el art\u00edculo seg\u00fan el identificador recibido en la ruta, sino existe el art\u00edculo devolvemos un error: art=Articulos.query.get(id) if art is None: abort(404) Creamos un nuevo formulario. Este formulario va a recibir la informaci\u00f3n que hemos introducido y enviado por el m\u00e9todo POST y la informaci\u00f3n del fichero que hemos subido, sin embargo al entrar por primera vez (m\u00e9todo GET) se va a rellenar con lo datos del objeto Articulos que hemos seleccionado: form=formArticulo(obj=art) Si el formulario es v\u00e1lido: ... if form.validate_on_submit(): #Borramos la imagen anterior if form.photo.data: os.remove(app.root_path+\"/static/upload/\"+art.image) try: f = form.photo.data nombre_fichero=secure_filename(f.filename) f.save(app.root_path+\"/static/upload/\"+nombre_fichero) except: nombre_fichero=\"\" else: nombre_fichero=art.image form.populate_obj(art) art.image=nombre_fichero db.session.commit() return redirect(url_for(\"inicio\")) Se realizan las siguientes acciones: Si hemos subido otra imagen se elimina la anterior. Se intenta guardar el fichero que se ha subido en el formulario. Si no se ha subido ninguno el nombre la imagen sigue siendo la anterior. Se modifica el objeto Articulos al rellenar con los datos del formulario ( form.populate_obj(art) ). Si el formulario no es v\u00e1lido se vuelve a generar la plantilla con el formulario con datos, mostrando si lo hemos codificado los errores de validaci\u00f3n oportunos. Modificando categor\u00edas \u00b6 De una forma similar puedes estudiar el c\u00f3digo para ver c\u00f3mo se modifican las categor\u00edas en nuestra base de datos. C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"6.5 Modificando registros en la base de datos"},{"location":"6_5_modificando.html#modificando-registros-en-la-base-de-datos","text":"En este apartado vamos a estudiar como modificar un registro en nuestra base de datos.","title":"Modificando registros en la base de datos"},{"location":"6_5_modificando.html#modificando-articulos","text":"Lo primero es insertar un enlace en la p\u00e1gina principal que nos permita modificar art\u00edculos (se a\u00f1ade un enlace por cada art\u00edculo), para ello en la plantilla inicio.html : <td><a href=\"{{url_for('articulos_edit',id=art.id)}}\"><span class=\"glyphicon glyphicon-pencil\"></span> Modificar</a></td> Vamos a usar el mismo formulario ( formArticulo ) que hemos utilizado en la unidad anterior para a\u00f1adir nuevos art\u00edculos, para realizar la modificaci\u00f3n. Vamos a utilizar el mismo template articulos_new.html para mostrar el formulario. En el programa principal, vamos a crear una ruta din\u00e1mica, que nos permite modificar un registro seg\u00fan su identificador: @app.route('/articulos/<id>/edit', methods=[\"get\",\"post\"]) Lo primero que hacemos es seleccionar el art\u00edculo seg\u00fan el identificador recibido en la ruta, sino existe el art\u00edculo devolvemos un error: art=Articulos.query.get(id) if art is None: abort(404) Creamos un nuevo formulario. Este formulario va a recibir la informaci\u00f3n que hemos introducido y enviado por el m\u00e9todo POST y la informaci\u00f3n del fichero que hemos subido, sin embargo al entrar por primera vez (m\u00e9todo GET) se va a rellenar con lo datos del objeto Articulos que hemos seleccionado: form=formArticulo(obj=art) Si el formulario es v\u00e1lido: ... if form.validate_on_submit(): #Borramos la imagen anterior if form.photo.data: os.remove(app.root_path+\"/static/upload/\"+art.image) try: f = form.photo.data nombre_fichero=secure_filename(f.filename) f.save(app.root_path+\"/static/upload/\"+nombre_fichero) except: nombre_fichero=\"\" else: nombre_fichero=art.image form.populate_obj(art) art.image=nombre_fichero db.session.commit() return redirect(url_for(\"inicio\")) Se realizan las siguientes acciones: Si hemos subido otra imagen se elimina la anterior. Se intenta guardar el fichero que se ha subido en el formulario. Si no se ha subido ninguno el nombre la imagen sigue siendo la anterior. Se modifica el objeto Articulos al rellenar con los datos del formulario ( form.populate_obj(art) ). Si el formulario no es v\u00e1lido se vuelve a generar la plantilla con el formulario con datos, mostrando si lo hemos codificado los errores de validaci\u00f3n oportunos.","title":"Modificando art\u00edculos"},{"location":"6_5_modificando.html#modificando-categorias","text":"De una forma similar puedes estudiar el c\u00f3digo para ver c\u00f3mo se modifican las categor\u00edas en nuestra base de datos.","title":"Modificando categor\u00edas"},{"location":"6_5_modificando.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"6_6_borrando.html","text":"Borrando un registro de la base de datos \u00b6 En este apartado vamos a estudiar como borrar un registro en nuestra base de datos. Modificando art\u00edculos \u00b6 Modificaci\u00f3n en el modelo de datos \u00b6 Vamos a modificar nuestro modelo de datos, para indicar que vamos a borrar en cascada en nuestra relaci\u00f3n, es decir al borrar una categor\u00eda vamos a borrar todos los videojuegos de esa categor\u00eda, para ello en el fichero models.py cambiamos la siguiente l\u00ednea en el modelo Categorias : articulos = relationship(\"Articulos\", cascade=\"all, delete-orphan\", backref=\"Categorias\",lazy='dynamic') Tenemos que volver a generar la base de datos para que tenga efecto este cambio. Borrando art\u00edculos \u00b6 Lo primero es insertar un enlace en la p\u00e1gina principal que nos permita borrar art\u00edculos (se a\u00f1ade un enlace por cada art\u00edculo), para ello en la plantilla inicio.html : <td><a href=\"{{url_for('articulos_delete',id=art.id)}}\"><span class=\"glyphicon glyphicon-trash\"></span> Borrar</a></td> Vamos a usar un formulario ( formSINO ) para confirmar que queremos borrar una art\u00edculo. Este formulario, simplemente nos ofrece dos botones (S\u00ed o No) para confirmar el borrado. En el fichero forms.py : class formSINO(FlaskForm): si = SubmitField('Si') no = SubmitField('No') Utilizamos el template articulos_delete.html para mostrar el formulario. En el programa principal, vamos a crear una ruta din\u00e1mica, que nos permite borrar un registro seg\u00fan su identificador: @app.route('/articulos/<id>/delete', methods=[\"get\",\"post\"]) Lo primero que hacemos es seleccionar el art\u00edculo seg\u00fan el identificador recibido en la ruta, sino existe el art\u00edculo devolvemos un error: art=Articulos.query.get(id) if art is None: abort(404) Creamos un formulario para confirmar el borrado ( formSINO ). Si en el formulario pulsamo \"Si\": form=formSINO() if form.validate_on_submit(): if form.si.data: if art.image!=\"\": os.remove(app.root_path+\"/static/upload/\"+art.image) db.session.delete(art) db.session.commit() return redirect(url_for(\"inicio\")) return render_template(\"articulos_delete.html\",form=form,art=art) Se realizan las siguientes acciones: Borramos el fichero de la imagen correspondiente, si ten\u00eda una imagen asociada.. Se borra el objeto Articulos que hemos seleccionado. Si el formulario no es v\u00e1lido o hemos pulsado \"No\" volvemos a la p\u00e1gina principal. Borrando categor\u00edas \u00b6 De una forma similar puedes estudiar el c\u00f3digo para ver c\u00f3mo se borran las categor\u00edas en nuestra base de datos. Comprueba que al borrar una categor\u00eda se borran todos los videojuegos asociados. C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"6.6. Borrando un Registro"},{"location":"6_6_borrando.html#borrando-un-registro-de-la-base-de-datos","text":"En este apartado vamos a estudiar como borrar un registro en nuestra base de datos.","title":"Borrando un registro de la base de datos"},{"location":"6_6_borrando.html#modificando-articulos","text":"","title":"Modificando art\u00edculos"},{"location":"6_6_borrando.html#modificacion-en-el-modelo-de-datos","text":"Vamos a modificar nuestro modelo de datos, para indicar que vamos a borrar en cascada en nuestra relaci\u00f3n, es decir al borrar una categor\u00eda vamos a borrar todos los videojuegos de esa categor\u00eda, para ello en el fichero models.py cambiamos la siguiente l\u00ednea en el modelo Categorias : articulos = relationship(\"Articulos\", cascade=\"all, delete-orphan\", backref=\"Categorias\",lazy='dynamic') Tenemos que volver a generar la base de datos para que tenga efecto este cambio.","title":"Modificaci\u00f3n en el modelo de datos"},{"location":"6_6_borrando.html#borrando-articulos","text":"Lo primero es insertar un enlace en la p\u00e1gina principal que nos permita borrar art\u00edculos (se a\u00f1ade un enlace por cada art\u00edculo), para ello en la plantilla inicio.html : <td><a href=\"{{url_for('articulos_delete',id=art.id)}}\"><span class=\"glyphicon glyphicon-trash\"></span> Borrar</a></td> Vamos a usar un formulario ( formSINO ) para confirmar que queremos borrar una art\u00edculo. Este formulario, simplemente nos ofrece dos botones (S\u00ed o No) para confirmar el borrado. En el fichero forms.py : class formSINO(FlaskForm): si = SubmitField('Si') no = SubmitField('No') Utilizamos el template articulos_delete.html para mostrar el formulario. En el programa principal, vamos a crear una ruta din\u00e1mica, que nos permite borrar un registro seg\u00fan su identificador: @app.route('/articulos/<id>/delete', methods=[\"get\",\"post\"]) Lo primero que hacemos es seleccionar el art\u00edculo seg\u00fan el identificador recibido en la ruta, sino existe el art\u00edculo devolvemos un error: art=Articulos.query.get(id) if art is None: abort(404) Creamos un formulario para confirmar el borrado ( formSINO ). Si en el formulario pulsamo \"Si\": form=formSINO() if form.validate_on_submit(): if form.si.data: if art.image!=\"\": os.remove(app.root_path+\"/static/upload/\"+art.image) db.session.delete(art) db.session.commit() return redirect(url_for(\"inicio\")) return render_template(\"articulos_delete.html\",form=form,art=art) Se realizan las siguientes acciones: Borramos el fichero de la imagen correspondiente, si ten\u00eda una imagen asociada.. Se borra el objeto Articulos que hemos seleccionado. Si el formulario no es v\u00e1lido o hemos pulsado \"No\" volvemos a la p\u00e1gina principal.","title":"Borrando art\u00edculos"},{"location":"6_6_borrando.html#borrando-categorias","text":"De una forma similar puedes estudiar el c\u00f3digo para ver c\u00f3mo se borran las categor\u00edas en nuestra base de datos. Comprueba que al borrar una categor\u00eda se borran todos los videojuegos asociados.","title":"Borrando categor\u00edas"},{"location":"6_6_borrando.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"7_1_gestion_usuarios.html","text":"Gesti\u00f3n de usuarios con sesiones \u00b6 En esta unidad vamos a introducir el concepto de sesi\u00f3n para posibilitar que los usuarios de nuestra p\u00e1gina puedan loguearse en ella. Posteriormente veremos como autorizar el acceso a las distintas opciones de nuestra aplicaci\u00f3n seg\u00fan el rol del usuario. En esta unidad vamos a trabajar directamente con sesiones, en una unidad posterior utilizarnos la extensi\u00f3n de Flask flask-login para realizar la autentificaci\u00f3n. El modelo de datos para guardar los usuarios \u00b6 Necesitamos una nueva tabla en nuestra base de datos para guardar los usuarios, para ello en nuestro modelo de datos (fichero models.py ) a\u00f1adimos la clase Usuarios : class Usuarios(db.Model): \"\"\"Usuarios\"\"\" __tablename__ = 'usuarios' id = Column(Integer, primary_key=True) username = Column(String(100),nullable=False) password_hash = Column(String(128),nullable=False) nombre = Column(String(200),nullable=False) email = Column(String(200),nullable=False) admin = Column(Boolean, default=False) def __repr__(self): return (u'<{self.__class__.__name__}: {self.id}>'.format(self=self)) @property def password(self): raise AttributeError('password is not a readable attribute') @password.setter def password(self, password): self.password_hash = generate_password_hash(password) def verify_password(self, password): return check_password_hash(self.password_hash, password) Algunas indicaciones interesantes: Los datos de usuario se van a guardar en una tabla llamada usuarios . Guardamos un identificador, un nombre de usuario, contrase\u00f1a (que estar\u00e1 cifrada), el nombre, el correo electr\u00f3nico y un valor l\u00f3gico (admin) que nos indica si el usuario es administrador. Vamos a tener dos roles de usuarios; administradores y usuarios normales. Tenemos una propiedad password . Al intentar obtener su valor, nos devuelve una excepci\u00f3n indicado que no se puede leer, si intentamos modificarla, lo que realmente se hace es cifrarla en el atributo password_hash con la funci\u00f3n generate_password_hash del m\u00f3dulo werkzeug.security . Tambi\u00e9n tenemos un m\u00e9todo verify_password que utilizando la funci\u00f3n check_password_hash del m\u00f3dulo werkzeug.security , nos permite verificar si la contrase\u00f1a guarda es igual a la indicada como par\u00e1metro. Tenemos que volver a generar las tablas para tener a nuestra disposici\u00f3n el nuevo modelo. Una vez realizada esta operaci\u00f3n podemos hacer una prueba, creando un usuario: >>> from aplicacion.app import db >>> from aplicacion.models import Usuarios >>> u=Usuarios() >>> u.nombre=\"pepe\" >>> u.password=\"asdasd\" >>> u.username=\"pepe\" >>> u.email=\"a@a.es\" >>> db.session.add(u) >>> db.session.commit() >>> u.password_hash >>> 'pbkdf2:sha256:50000$EFhxMbr1$ea8e6ddeaaac8d73d01f78f1b3d3120184cc25aea9491e632b4fc8c9ae2705cb' >>> u.password Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"/home/jose/github/curso_flask/ejemplos/u27/aplicacion/models.py\", line 53, in password raise AttributeError('password is not a readable attribute') AttributeError: password is not a readable attribute Creaci\u00f3n del usuario administrador \u00b6 Para facilitar la creaci\u00f3n de un primer usuario con rol administrador hemos introducido una nueva funcionalidad en nuestro script manage.py : @manager.command def create_admin(): usuario={\"username\":input(\"Usuario:\"), \"password\":getpass(\"Password:\"), \"nombre\":input(\"Nombre completo:\"), \"email\":input(\"Email:\"), \"admin\": True} usu=Usuarios(**usuario) db.session.add(usu) db.session.commit() Que nos pide los datos del usuario por teclado y crea un usuario administrador: $ python3 manage.py create_admin Usuario: ... Autentficando usuarios en nuestra aplicaci\u00f3n \u00b6 Una vez que tenemos preparado nuestro modelo de datos y utilizando sesiones vamos a programar la posibilidad de que un usuario se autentifique en nuestra aplicaci\u00f3n y simulemos una sesi\u00f3n en ella hasta que salga del sistema. Para ello vamos a realizar los siguientes pasos: El formulario LoginForm nos va posibilitar pedir nombre de usuario y contrase\u00f1a para verificar si es un usuario correcto, por lo tanto en el fichero forms.py : class LoginForm(FlaskForm): username = StringField('Login', validators=[Required()]) password = PasswordField('Password', validators=[Required()]) submit = SubmitField('Entrar') Flask nos permite trabajar con sesiones, hemos creado un fichero login.py con el siguiente contenido: def login_user(Usuario): session[\"id\"]=Usuario.id session[\"username\"]=Usuario.username session[\"admin\"]=Usuario.admin def logout_user(): session.pop(\"id\",None) session.pop(\"username\",None) session.pop(\"admin\",None) Cuando un usuario se haya logueado de manera adecuada, utilizaremos la funci\u00f3n login_user para crear variables de sesiones con la informaci\u00f3n del identificador, el nombre de usuario y su rol. si el usuario sale del sistema se utilizar\u00e1 la funci\u00f3n logout_user para borrar dichas variables y terminar la sesi\u00f3n. Por lo tanto si existe alguna de las variables session tendremos un usuario logueado en el sistema. Esta variable es accesible desde las plantillas, por lo tanto en la plantilla base.html podemos introducir el siguiente c\u00f3digo: {% if session[\"id\"] %} <a class=\"navbar-brand \" href=\"/logout\"> Hola, {{ session[\"username\"]}} (Salir)</a> {% else %} <a class=\"navbar-brand \" href=\"/login\">Login</a> {% endif %} Si existe la variable session[\"id\"] tenemos un usuario en el sistema: ponemos su nombre de usuario y un enlace a \"Salir\". Si esa variable no existe ponemos un enlace para posibilitar que el usuario introduzca sus credenciales. En el programa principal, creamos una ruta login que muestra el formulario de login, si mandamos el formulario con \u00e9xito busca el usuario en la base de datos y comprueba la contrase\u00f1a indicada si todo es correcto crea la sesi\u00f3n con la funci\u00f3n login_user() : @app.route('/login', methods=['get', 'post']) def login(): form = LoginForm() if form.validate_on_submit(): user=Usuarios.query.filter_by(username=form.username.data).first() if user!=None and user.verify_password(form.password.data): login_user(user) return redirect(url_for('inicio')) form.username.errors.append(\"Usuario o contrase\u00f1a incorrectas.\") return render_template('login.html', form=form) Tambi\u00e9n hemos creado una ruta logout que nos permite al usuario terminar la sesi\u00f3n utilizando la funci\u00f3n `logout_user(): @app.route(\"/logout\") def logout(): logout_user() return redirect(url_for('login')) En la siguiente unidad veremos como posibilitar que los usuarios se registren en nuestra aplicaci\u00f3n, creando nuevos usuarios y posteriormente veremos como autorizar las distintas operaciones que puede realizar un usuario seg\u00fan su rol. C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"7.1 Gesti\u00f3n de usuarios con sesiones"},{"location":"7_1_gestion_usuarios.html#gestion-de-usuarios-con-sesiones","text":"En esta unidad vamos a introducir el concepto de sesi\u00f3n para posibilitar que los usuarios de nuestra p\u00e1gina puedan loguearse en ella. Posteriormente veremos como autorizar el acceso a las distintas opciones de nuestra aplicaci\u00f3n seg\u00fan el rol del usuario. En esta unidad vamos a trabajar directamente con sesiones, en una unidad posterior utilizarnos la extensi\u00f3n de Flask flask-login para realizar la autentificaci\u00f3n.","title":"Gesti\u00f3n de usuarios con sesiones"},{"location":"7_1_gestion_usuarios.html#el-modelo-de-datos-para-guardar-los-usuarios","text":"Necesitamos una nueva tabla en nuestra base de datos para guardar los usuarios, para ello en nuestro modelo de datos (fichero models.py ) a\u00f1adimos la clase Usuarios : class Usuarios(db.Model): \"\"\"Usuarios\"\"\" __tablename__ = 'usuarios' id = Column(Integer, primary_key=True) username = Column(String(100),nullable=False) password_hash = Column(String(128),nullable=False) nombre = Column(String(200),nullable=False) email = Column(String(200),nullable=False) admin = Column(Boolean, default=False) def __repr__(self): return (u'<{self.__class__.__name__}: {self.id}>'.format(self=self)) @property def password(self): raise AttributeError('password is not a readable attribute') @password.setter def password(self, password): self.password_hash = generate_password_hash(password) def verify_password(self, password): return check_password_hash(self.password_hash, password) Algunas indicaciones interesantes: Los datos de usuario se van a guardar en una tabla llamada usuarios . Guardamos un identificador, un nombre de usuario, contrase\u00f1a (que estar\u00e1 cifrada), el nombre, el correo electr\u00f3nico y un valor l\u00f3gico (admin) que nos indica si el usuario es administrador. Vamos a tener dos roles de usuarios; administradores y usuarios normales. Tenemos una propiedad password . Al intentar obtener su valor, nos devuelve una excepci\u00f3n indicado que no se puede leer, si intentamos modificarla, lo que realmente se hace es cifrarla en el atributo password_hash con la funci\u00f3n generate_password_hash del m\u00f3dulo werkzeug.security . Tambi\u00e9n tenemos un m\u00e9todo verify_password que utilizando la funci\u00f3n check_password_hash del m\u00f3dulo werkzeug.security , nos permite verificar si la contrase\u00f1a guarda es igual a la indicada como par\u00e1metro. Tenemos que volver a generar las tablas para tener a nuestra disposici\u00f3n el nuevo modelo. Una vez realizada esta operaci\u00f3n podemos hacer una prueba, creando un usuario: >>> from aplicacion.app import db >>> from aplicacion.models import Usuarios >>> u=Usuarios() >>> u.nombre=\"pepe\" >>> u.password=\"asdasd\" >>> u.username=\"pepe\" >>> u.email=\"a@a.es\" >>> db.session.add(u) >>> db.session.commit() >>> u.password_hash >>> 'pbkdf2:sha256:50000$EFhxMbr1$ea8e6ddeaaac8d73d01f78f1b3d3120184cc25aea9491e632b4fc8c9ae2705cb' >>> u.password Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"/home/jose/github/curso_flask/ejemplos/u27/aplicacion/models.py\", line 53, in password raise AttributeError('password is not a readable attribute') AttributeError: password is not a readable attribute","title":"El modelo de datos para guardar los usuarios"},{"location":"7_1_gestion_usuarios.html#creacion-del-usuario-administrador","text":"Para facilitar la creaci\u00f3n de un primer usuario con rol administrador hemos introducido una nueva funcionalidad en nuestro script manage.py : @manager.command def create_admin(): usuario={\"username\":input(\"Usuario:\"), \"password\":getpass(\"Password:\"), \"nombre\":input(\"Nombre completo:\"), \"email\":input(\"Email:\"), \"admin\": True} usu=Usuarios(**usuario) db.session.add(usu) db.session.commit() Que nos pide los datos del usuario por teclado y crea un usuario administrador: $ python3 manage.py create_admin Usuario: ...","title":"Creaci\u00f3n del usuario administrador"},{"location":"7_1_gestion_usuarios.html#autentficando-usuarios-en-nuestra-aplicacion","text":"Una vez que tenemos preparado nuestro modelo de datos y utilizando sesiones vamos a programar la posibilidad de que un usuario se autentifique en nuestra aplicaci\u00f3n y simulemos una sesi\u00f3n en ella hasta que salga del sistema. Para ello vamos a realizar los siguientes pasos: El formulario LoginForm nos va posibilitar pedir nombre de usuario y contrase\u00f1a para verificar si es un usuario correcto, por lo tanto en el fichero forms.py : class LoginForm(FlaskForm): username = StringField('Login', validators=[Required()]) password = PasswordField('Password', validators=[Required()]) submit = SubmitField('Entrar') Flask nos permite trabajar con sesiones, hemos creado un fichero login.py con el siguiente contenido: def login_user(Usuario): session[\"id\"]=Usuario.id session[\"username\"]=Usuario.username session[\"admin\"]=Usuario.admin def logout_user(): session.pop(\"id\",None) session.pop(\"username\",None) session.pop(\"admin\",None) Cuando un usuario se haya logueado de manera adecuada, utilizaremos la funci\u00f3n login_user para crear variables de sesiones con la informaci\u00f3n del identificador, el nombre de usuario y su rol. si el usuario sale del sistema se utilizar\u00e1 la funci\u00f3n logout_user para borrar dichas variables y terminar la sesi\u00f3n. Por lo tanto si existe alguna de las variables session tendremos un usuario logueado en el sistema. Esta variable es accesible desde las plantillas, por lo tanto en la plantilla base.html podemos introducir el siguiente c\u00f3digo: {% if session[\"id\"] %} <a class=\"navbar-brand \" href=\"/logout\"> Hola, {{ session[\"username\"]}} (Salir)</a> {% else %} <a class=\"navbar-brand \" href=\"/login\">Login</a> {% endif %} Si existe la variable session[\"id\"] tenemos un usuario en el sistema: ponemos su nombre de usuario y un enlace a \"Salir\". Si esa variable no existe ponemos un enlace para posibilitar que el usuario introduzca sus credenciales. En el programa principal, creamos una ruta login que muestra el formulario de login, si mandamos el formulario con \u00e9xito busca el usuario en la base de datos y comprueba la contrase\u00f1a indicada si todo es correcto crea la sesi\u00f3n con la funci\u00f3n login_user() : @app.route('/login', methods=['get', 'post']) def login(): form = LoginForm() if form.validate_on_submit(): user=Usuarios.query.filter_by(username=form.username.data).first() if user!=None and user.verify_password(form.password.data): login_user(user) return redirect(url_for('inicio')) form.username.errors.append(\"Usuario o contrase\u00f1a incorrectas.\") return render_template('login.html', form=form) Tambi\u00e9n hemos creado una ruta logout que nos permite al usuario terminar la sesi\u00f3n utilizando la funci\u00f3n `logout_user(): @app.route(\"/logout\") def logout(): logout_user() return redirect(url_for('login')) En la siguiente unidad veremos como posibilitar que los usuarios se registren en nuestra aplicaci\u00f3n, creando nuevos usuarios y posteriormente veremos como autorizar las distintas operaciones que puede realizar un usuario seg\u00fan su rol.","title":"Autentficando usuarios en nuestra aplicaci\u00f3n"},{"location":"7_1_gestion_usuarios.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"7_2_nuevos_usaurios.html","text":"Registrando nuevos usuarios \u00b6 En esta unidad vamos a estudiar como un usuario se puede registrar en nuestra aplicaci\u00f3n, y una vez registrado podr\u00e1 cambiar los datos de su perfil. En realidad lo que estamos haciendo es creando y modificando registros en la tabla de usuarios. Registro de nuevos usuarios \u00b6 En la plantilla base.html hemos introducido un enlace para el registro de nuevos usuarios (si no hay un usuario logueado) y para acceder al perfil (si el usuario est\u00e1 logueado): {% if session[\"id\"] %} <a class=\"navbar-brand \" href=\"/perfil/{{ session[\"username\"]}}\"> Perfil</a> <a class=\"navbar-brand \" href=\"/logout\"> {{ session[\"username\"]}} (Salir)</a> {% else %} <a class=\"navbar-brand \" href=\"/login\">Login</a> <a class=\"navbar-brand \" href=\"/registro\">Registro</a> {% endif %} En el programa principal hemos creado una ruta registro que nos permite mostrar el formulario de registro, si los datos introducidos son v\u00e1lidos (el usuario indicado no existe en la base de datos) se crea un nuevo usuario: @app.route(\"/registro\",methods=[\"get\",\"post\"]) def registro(): form=formUsuario() if form.validate_on_submit(): existe_usuario=Usuarios.query.filter_by(username=form.username.data).first() if existe_usuario==None: user=Usuarios() form.populate_obj(user) user.admin=False db.session.add(user) db.session.commit() return redirect(url_for(\"inicio\")) form.username.errors.append(\"Nombre de usuario ya existe.\") return render_template(\"usuarios_new.html\",form=form) El formulario utilizado para crear el nuevo usuario se llama formUsuario y lo puedes ver en el fichero forms.py . Modificaci\u00f3n de los datos de un usuario (perfil) \u00b6 El usuario puede modificar sus datos accediendo a la ruta perfil . Utilizamos el mismo formulario formUsuario , pero la plantilla que lo visualiza ( usuarios_new.html ) muestra elementos diferentes seg\u00fan sea el registro o el perfil: Si estamos registrando un nuevo usuario muestra un cuadro de texto para introducir el nombre de usuario, si estamos en el perfil muestra el mismo cuadro de texto pero en modo s\u00f3lo lectura, para simplificar el proceso: {% if not perfil %} {{form.username.label() }}{{form.username(size=\"100\",class=\"form-control\")}}<br/> {% else %} {{form.username.label() }}{{form.username(readonly=\"readonly\",size=\"100\",class=\"form-control\")}}<br/> {% endif %} Si estamos registrando un nuevo usuario muestra un cuadro de texto para introducir la contrase\u00f1a, si estamos en el perfil muestra un enlace para cambiar la contrase\u00f1a: {% if not perfil %} {{form.password.label() }}{{form.password(size=\"100\",class=\"form-control\")}}<br/> {% else %} <a href=\"/changepassword/{{session[\"username\"]}}\">Cambiar contrase\u00f1a</a><br/> {% endif %} La ruta perfil muetra el formulario y cambia los datos que modifiquemos, menos la contrase\u00f1a: @app.route('/perfil/<username>', methods=[\"get\",\"post\"]) def perfil(username): user=Usuarios.query.filter_by(username=username).first() if user is None: abort(404) form=formUsuario(request.form,obj=user) del form.password if form.validate_on_submit(): form.populate_obj(user) db.session.commit() return redirect(url_for(\"inicio\")) return render_template(\"usuarios_new.html\",form=form,perfil=True) Cambio de contrase\u00f1a \u00b6 Un usuario registrado tambi\u00e9n puede cambiar su contrase\u00f1a, pero lo hemos realizado en una plantilla independiente ( changepassword.html ) y un formulario formChangePassword . Para realizar el cambio de contrase\u00f1a hemos creado la ruta changepassword : @app.route('/changepassword/<username>', methods=[\"get\",\"post\"]) def changepassword(username): user=Usuarios.query.filter_by(username=username).first() if user is None: abort(404) form=formChangePassword() if form.validate_on_submit(): form.populate_obj(user) db.session.commit() return redirect(url_for(\"inicio\")) return render_template(\"changepassword.html\",form=form) C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"7.2 Registrando nuevos usuarios"},{"location":"7_2_nuevos_usaurios.html#registrando-nuevos-usuarios","text":"En esta unidad vamos a estudiar como un usuario se puede registrar en nuestra aplicaci\u00f3n, y una vez registrado podr\u00e1 cambiar los datos de su perfil. En realidad lo que estamos haciendo es creando y modificando registros en la tabla de usuarios.","title":"Registrando nuevos usuarios"},{"location":"7_2_nuevos_usaurios.html#registro-de-nuevos-usuarios","text":"En la plantilla base.html hemos introducido un enlace para el registro de nuevos usuarios (si no hay un usuario logueado) y para acceder al perfil (si el usuario est\u00e1 logueado): {% if session[\"id\"] %} <a class=\"navbar-brand \" href=\"/perfil/{{ session[\"username\"]}}\"> Perfil</a> <a class=\"navbar-brand \" href=\"/logout\"> {{ session[\"username\"]}} (Salir)</a> {% else %} <a class=\"navbar-brand \" href=\"/login\">Login</a> <a class=\"navbar-brand \" href=\"/registro\">Registro</a> {% endif %} En el programa principal hemos creado una ruta registro que nos permite mostrar el formulario de registro, si los datos introducidos son v\u00e1lidos (el usuario indicado no existe en la base de datos) se crea un nuevo usuario: @app.route(\"/registro\",methods=[\"get\",\"post\"]) def registro(): form=formUsuario() if form.validate_on_submit(): existe_usuario=Usuarios.query.filter_by(username=form.username.data).first() if existe_usuario==None: user=Usuarios() form.populate_obj(user) user.admin=False db.session.add(user) db.session.commit() return redirect(url_for(\"inicio\")) form.username.errors.append(\"Nombre de usuario ya existe.\") return render_template(\"usuarios_new.html\",form=form) El formulario utilizado para crear el nuevo usuario se llama formUsuario y lo puedes ver en el fichero forms.py .","title":"Registro de nuevos usuarios"},{"location":"7_2_nuevos_usaurios.html#modificacion-de-los-datos-de-un-usuario-perfil","text":"El usuario puede modificar sus datos accediendo a la ruta perfil . Utilizamos el mismo formulario formUsuario , pero la plantilla que lo visualiza ( usuarios_new.html ) muestra elementos diferentes seg\u00fan sea el registro o el perfil: Si estamos registrando un nuevo usuario muestra un cuadro de texto para introducir el nombre de usuario, si estamos en el perfil muestra el mismo cuadro de texto pero en modo s\u00f3lo lectura, para simplificar el proceso: {% if not perfil %} {{form.username.label() }}{{form.username(size=\"100\",class=\"form-control\")}}<br/> {% else %} {{form.username.label() }}{{form.username(readonly=\"readonly\",size=\"100\",class=\"form-control\")}}<br/> {% endif %} Si estamos registrando un nuevo usuario muestra un cuadro de texto para introducir la contrase\u00f1a, si estamos en el perfil muestra un enlace para cambiar la contrase\u00f1a: {% if not perfil %} {{form.password.label() }}{{form.password(size=\"100\",class=\"form-control\")}}<br/> {% else %} <a href=\"/changepassword/{{session[\"username\"]}}\">Cambiar contrase\u00f1a</a><br/> {% endif %} La ruta perfil muetra el formulario y cambia los datos que modifiquemos, menos la contrase\u00f1a: @app.route('/perfil/<username>', methods=[\"get\",\"post\"]) def perfil(username): user=Usuarios.query.filter_by(username=username).first() if user is None: abort(404) form=formUsuario(request.form,obj=user) del form.password if form.validate_on_submit(): form.populate_obj(user) db.session.commit() return redirect(url_for(\"inicio\")) return render_template(\"usuarios_new.html\",form=form,perfil=True)","title":"Modificaci\u00f3n de los datos de un usuario (perfil)"},{"location":"7_2_nuevos_usaurios.html#cambio-de-contrasena","text":"Un usuario registrado tambi\u00e9n puede cambiar su contrase\u00f1a, pero lo hemos realizado en una plantilla independiente ( changepassword.html ) y un formulario formChangePassword . Para realizar el cambio de contrase\u00f1a hemos creado la ruta changepassword : @app.route('/changepassword/<username>', methods=[\"get\",\"post\"]) def changepassword(username): user=Usuarios.query.filter_by(username=username).first() if user is None: abort(404) form=formChangePassword() if form.validate_on_submit(): form.populate_obj(user) db.session.commit() return redirect(url_for(\"inicio\")) return render_template(\"changepassword.html\",form=form)","title":"Cambio de contrase\u00f1a"},{"location":"7_2_nuevos_usaurios.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"7_3_gestion_permisos.html","text":"Gesti\u00f3n de permisos de usuarios \u00b6 En esta unidad vamos a estudiar como autorizar las distintas acciones que pueden hacer nuestros usuarios en la aplicaci\u00f3n. Cuando accedemos a la aplicaci\u00f3n podemos hacerlo de tres formas distintas: Usuario invitado: Navegamos por la p\u00e1gina sin autentificar ning\u00fan usuario del sistema. Usuario normal: Nos hemos autentificado con un usuario que no es administrador. Usuario administrador: Nos hemos autentificado con un usuario administrador. Control de acceso \u00b6 Veamos una tabla donde indicamos seg\u00fan el tipo de usuario con el que estamos trabajando las distintas acciones que se pueden realizar: Acci\u00f3n Invitado Normal Administrador Hacer login Si No No Registrarse Si No No Ver perfil No Si Si Puede cambiar la contrase\u00f1a No Si Si Puede ver los videojuegos Si Si Si Puede ver las categor\u00edas Si Si Si Puede a\u00f1adir categor\u00edas y videojuegos No No Si Puede modificar y borrar categor\u00edas y videojuegos No No Si Puede comprar videojuegos No Si Si \u00bfC\u00f3mo determinamos la clase de usuario con el que estamos trabajando? \u00b6 En la unidad anterior, pregunt\u00e1bamos por la existencia de las variables de sesi\u00f3n: Que est\u00e1s logueado (usuario normal): if session[\"id\"] Qu\u00e9 est\u00e1s logueado y es administrador: if session[\"admin\"] En esta unidad vamos a crear dos funciones en el fichero login.py para realizar esta tarea de forma m\u00e1s elegante: def is_login(): if \"id\" in session: return True else: return False def is_admin(): return session.get(\"admin\",False) Por otro lado, en unidades anteriores no ten\u00edamos ning\u00fan problema al preguntar por la variable session en las plantillas, si queremos hacerlo un poco m\u00e1s elegante podr\u00edamos crear dos variables en el contexto de las plantillas que me permitan determinar el rol del usuario, para ello en el mismo fichero login.py : @app.context_processor def login(): if \"id\" in session: return {'is_login':True} else: return {'is_login':False} @app.context_processor def admin(): return {'is_admin':session.get(\"admin\",False) } Donde creamos dos variables: is_login y is_admin que podemos utilizar en las plantillas. Control de acceso \u00b6 Por ejemplo la ruta /articulos/new que nos permite a\u00f1adir un videojuego s\u00f3lo se deber\u00eda permitir a los usuarios administradores, por lo que al principio realizamos la comprobaci\u00f3n: if not is_admin(): abort(404) Otro ejemplo, s\u00f3lo podemos registrarnos si no estamos con un usuario logueado, por lo tanto en la ruta registro preguntamos: if is_login(): return redirect(url_for(\"inicio\")) Generando contenido seg\u00fan el tipo de usuario \u00b6 Adem\u00e1s del control de acceso anterior tenemos que hacer que las plantillas generen contenido distintos seg\u00fan le tipo de usuario que tengamos en el sistema. Por ejemplo, s\u00f3lo le debemos mostrar el enlace de a\u00f1adir videojuegos a los usuarios administradores, para ello en la plantilla inicio.html : {% if is_admin %} <a class=\"btn btn-primary\" href=\"{{url_for('articulos_new')}}\" role=\"button\">Nuevo videojuego</a> {% endif %} Otro ejemplo, mostramos la opci\u00f3n de \"Registro\" y \"Login\" para los usuarios invitados, y la opci\u00f3n de \"Perfil\" y de \"Salir\" para los usuarios logueados, para ello en la plantilla base.html : {% if is_login %} <a class=\"navbar-brand \" href=\"/perfil/{{ session[\"username\"]}}\"> Perfil</a> <a class=\"navbar-brand \" href=\"/logout\"> {{ session[\"username\"]}} (Salir)</a> {% else %} <a class=\"navbar-brand \" href=\"/login\">Login</a> <a class=\"navbar-brand \" href=\"/registro\">Registro</a> {% endif %} Para terminar con otro ejemplo, solo los administradores pueden modificar y borrar videojuegos, y los usuarios logueados pueden comprar, en la plantilla inicio.html tenemos el siguiente c\u00f3digo: {% if is_admin %} <td><a href=\"{{url_for('articulos_edit',id=art.id)}}\"><span class=\"glyphicon glyphicon-pencil\"></span> Modificar</a></td> <td><a href=\"{{url_for('articulos_delete',id=art.id)}}\"><span class=\"glyphicon glyphicon-trash\"></span> Borrar</a></td> {% endif %} {% if is_login %} <td><a href=\"#\"><span class=\"glyphicon glyphicon-shopping-cart\"></span> Comprar</a></td> {% endif %} C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"7.3 Gesti\u00f3n de permisos de usuarios"},{"location":"7_3_gestion_permisos.html#gestion-de-permisos-de-usuarios","text":"En esta unidad vamos a estudiar como autorizar las distintas acciones que pueden hacer nuestros usuarios en la aplicaci\u00f3n. Cuando accedemos a la aplicaci\u00f3n podemos hacerlo de tres formas distintas: Usuario invitado: Navegamos por la p\u00e1gina sin autentificar ning\u00fan usuario del sistema. Usuario normal: Nos hemos autentificado con un usuario que no es administrador. Usuario administrador: Nos hemos autentificado con un usuario administrador.","title":"Gesti\u00f3n de permisos de usuarios"},{"location":"7_3_gestion_permisos.html#control-de-acceso","text":"Veamos una tabla donde indicamos seg\u00fan el tipo de usuario con el que estamos trabajando las distintas acciones que se pueden realizar: Acci\u00f3n Invitado Normal Administrador Hacer login Si No No Registrarse Si No No Ver perfil No Si Si Puede cambiar la contrase\u00f1a No Si Si Puede ver los videojuegos Si Si Si Puede ver las categor\u00edas Si Si Si Puede a\u00f1adir categor\u00edas y videojuegos No No Si Puede modificar y borrar categor\u00edas y videojuegos No No Si Puede comprar videojuegos No Si Si","title":"Control de acceso"},{"location":"7_3_gestion_permisos.html#como-determinamos-la-clase-de-usuario-con-el-que-estamos-trabajando","text":"En la unidad anterior, pregunt\u00e1bamos por la existencia de las variables de sesi\u00f3n: Que est\u00e1s logueado (usuario normal): if session[\"id\"] Qu\u00e9 est\u00e1s logueado y es administrador: if session[\"admin\"] En esta unidad vamos a crear dos funciones en el fichero login.py para realizar esta tarea de forma m\u00e1s elegante: def is_login(): if \"id\" in session: return True else: return False def is_admin(): return session.get(\"admin\",False) Por otro lado, en unidades anteriores no ten\u00edamos ning\u00fan problema al preguntar por la variable session en las plantillas, si queremos hacerlo un poco m\u00e1s elegante podr\u00edamos crear dos variables en el contexto de las plantillas que me permitan determinar el rol del usuario, para ello en el mismo fichero login.py : @app.context_processor def login(): if \"id\" in session: return {'is_login':True} else: return {'is_login':False} @app.context_processor def admin(): return {'is_admin':session.get(\"admin\",False) } Donde creamos dos variables: is_login y is_admin que podemos utilizar en las plantillas.","title":"\u00bfC\u00f3mo determinamos la clase de usuario con el que estamos trabajando?"},{"location":"7_3_gestion_permisos.html#control-de-acceso_1","text":"Por ejemplo la ruta /articulos/new que nos permite a\u00f1adir un videojuego s\u00f3lo se deber\u00eda permitir a los usuarios administradores, por lo que al principio realizamos la comprobaci\u00f3n: if not is_admin(): abort(404) Otro ejemplo, s\u00f3lo podemos registrarnos si no estamos con un usuario logueado, por lo tanto en la ruta registro preguntamos: if is_login(): return redirect(url_for(\"inicio\"))","title":"Control de acceso"},{"location":"7_3_gestion_permisos.html#generando-contenido-segun-el-tipo-de-usuario","text":"Adem\u00e1s del control de acceso anterior tenemos que hacer que las plantillas generen contenido distintos seg\u00fan le tipo de usuario que tengamos en el sistema. Por ejemplo, s\u00f3lo le debemos mostrar el enlace de a\u00f1adir videojuegos a los usuarios administradores, para ello en la plantilla inicio.html : {% if is_admin %} <a class=\"btn btn-primary\" href=\"{{url_for('articulos_new')}}\" role=\"button\">Nuevo videojuego</a> {% endif %} Otro ejemplo, mostramos la opci\u00f3n de \"Registro\" y \"Login\" para los usuarios invitados, y la opci\u00f3n de \"Perfil\" y de \"Salir\" para los usuarios logueados, para ello en la plantilla base.html : {% if is_login %} <a class=\"navbar-brand \" href=\"/perfil/{{ session[\"username\"]}}\"> Perfil</a> <a class=\"navbar-brand \" href=\"/logout\"> {{ session[\"username\"]}} (Salir)</a> {% else %} <a class=\"navbar-brand \" href=\"/login\">Login</a> <a class=\"navbar-brand \" href=\"/registro\">Registro</a> {% endif %} Para terminar con otro ejemplo, solo los administradores pueden modificar y borrar videojuegos, y los usuarios logueados pueden comprar, en la plantilla inicio.html tenemos el siguiente c\u00f3digo: {% if is_admin %} <td><a href=\"{{url_for('articulos_edit',id=art.id)}}\"><span class=\"glyphicon glyphicon-pencil\"></span> Modificar</a></td> <td><a href=\"{{url_for('articulos_delete',id=art.id)}}\"><span class=\"glyphicon glyphicon-trash\"></span> Borrar</a></td> {% endif %} {% if is_login %} <td><a href=\"#\"><span class=\"glyphicon glyphicon-shopping-cart\"></span> Comprar</a></td> {% endif %}","title":"Generando contenido seg\u00fan el tipo de usuario"},{"location":"7_3_gestion_permisos.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"7_4_gestion_usu_flask_login.html","text":"Gesti\u00f3n de usuarios con extensi\u00f3n Flask-Login \u00b6 En las unidades anteriores hemos gestionado las sesiones con Flask de manera manual, gestionando las variables de sesi\u00f3n (fichero login.py ) directamente y comprobando su existencia para el control de acceso. En esta unidad vamos a introducir una nueva extensi\u00f3n de Flask que nos permite trabajar con sesiones: Flask-Login . \u02cbFlask-Login\u02cb es una librer\u00eda que nos proporciona la posibilidad de gestionar las sesiones de nuestros usuarios; se ocupa de las tareas comunes: como el inicio de sesi\u00f3n, logout y recordar las sesiones de los usuarios durante periodos de tiempo personalizados. Con esta extensi\u00f3n podemos almacenar el identificador de la sesi\u00f3n del usuario activo, y nos permite abrir o cerrar una sesi\u00f3n, nos permite restringir vistas o rutas a usuarios sin sesi\u00f3n activa. Con esta extensi\u00f3n no podemos restringir el comportamiento de una vista seg\u00fan el rol de usuario. Instalaci\u00f3n y configuraci\u00f3n de flask-login \u00b6 Con nuestro entorno virtual activado: pip install Flask-Login En el programa principal configuramos la extensi\u00f3n: from flask_login import LoginManager,login_user,logout_user,login_required,current_user ... login_manager = LoginManager() login_manager.init_app(app) login_manager.login_view = \"login\" Flask-Login nos provee de diversas funciones muy interesantes para el uso de sesiones y a continuaci\u00f3n te presento las m\u00e1s interesantes: login_user : Esta funci\u00f3n permite crear la sesi\u00f3n de un usuario. logout_user : Esta funci\u00f3n permite terminar la sesi\u00f3n actual. login_required : Es un decorador que nos permite restringir la ejecuci\u00f3n de una vista s\u00f3lo a los usuarios logueados. current_user : Es un objeto con la informaci\u00f3n del usuario autentificado. Revisando el modelo de datos \u00b6 En el modelo de datos que representa los usuarios hay que a\u00f1adirle los siguiente nuevos m\u00e9todos: def is_authenticated(self): return True def is_active(self): return True def is_anonymous(self): return False def get_id(self): return str(self.id) def is_admin(self): return self.admin is_authenticated : Devuelve \"True\" si el usuario se autentifica, es decir, que ha proporcionado unas credenciales v\u00e1lidas. is_active : Devuelve \"True\" si el usuario se encuentra activo. Adem\u00e1s de ser autenticado, tambi\u00e9n han activado su cuenta, no se ha suspendido, o cualquier condici\u00f3n que su aplicaci\u00f3n requiera para rechazar una cuenta. Esto no lo hemos tenido en cuenta en nuestro modelo de datos. is_anonymous : Retorna \"True\" si se detecta que es la sesi\u00f3n de usuario an\u00f3nimo. La respuesta es \"False\" cuando se detecta que es un usuario con unas sesi\u00f3n correcta. get_id : Nos devuelve una cadena en Unicode que identifica de forma \u00fanica a un usuario logueado en el sistema. is_admin : devuelve \"True\" si el usuario logueado es administrador. Llamando al cargador de User \u00b6 La extensi\u00f3n Flask-Login no nos permite acceder directamente a la tabla de usuarios para obtener la informaci\u00f3n de un determinado usuario, por lo tanto en el programa principal tenemos que escribir una funci\u00f3n que va a utilizar Flask-Login: @login_manager.user_loader def load_user(user_id): return Usuarios.query.get(int(user_id)) Control de acceso \u00b6 Por ejemplo, para poder cambiar la contrase\u00f1a el usuario tiene que estar logueado, para restringir el acceso utilizamos el decorador login_required : @app.route('/changepassword/<username>', methods=[\"get\",\"post\"]) @login_required def ... Sin embrgo si queremos restringuir por el rol, por ejemplo: la ruta /articulos/new que nos permite a\u00f1adir un videojuego s\u00f3lo se deber\u00eda permitir a los usuarios adminitradores, deber\u00e1imos codificarlo de la siguiente manera: @app.route('/articulos/new', methods=[\"get\",\"post\"]) @login_required def articulos_new(): if not current_user.is_admin(): abort(404) Otro ejemplo, s\u00f3lo podemos registrarnos si no estamos con un usuario logueado, por lo tento en la ruta registro preguntamos: @app.route(\"/registro\",methods=[\"get\",\"post\"]) def registro(): if current_user.is_authenticated: return redirect(url_for(\"inicio\")) Generando contenido seg\u00fan el tipo de usuario \u00b6 Adem\u00e1s del control de acceso anterior tenemos que hacer que las plantillas generen contenido distintos seg\u00fan el tipo de usuario que tengamos en el sistema. Por ejemplo, s\u00f3lo le debemos mostrar el enlace de a\u00f1adir videojuegos a los usuarios administradores, para ello en la plantilla inicio.html : {% if current_user.is_authentificated and current_user.is_admin() %} <a class=\"btn btn-primary\" href=\"{{url_for('articulos_new')}}\" role=\"button\">Nuevo videojuego</a> {% endif %} Otro ejemplo, mostramos la opci\u00f3n de \"Registro\" y \"Login\" para los usuarios invitados, y la opci\u00f3n de \"Perfil\" y de \"Salir\" para los usuarios logueados, para ello en la plantilla base.html : {% if current_user.is_authenticated %} <a class=\"navbar-brand \" href=\"/perfil/{{ session[\"username\"]}}\"> Perfil</a> <a class=\"navbar-brand \" href=\"/logout\"> {{ session[\"username\"]}} (Salir)</a> {% else %} <a class=\"navbar-brand \" href=\"/login\">Login</a> <a class=\"navbar-brand \" href=\"/registro\">Registro</a> {% endif %} Para terminar con otro ejemplo, solo los administradores pueden modificar y borrar videojuegos, y los usuarios logueados pueden comprar, en la plantilla inicio.html tenemos el siguiente c\u00f3digo: {% if current_user.is_authentificated and current_user.is_admin() %} <td><a href=\"{{url_for('articulos_edit',id=art.id)}}\"><span class=\"glyphicon glyphicon-pencil\"></span> Modificar</a></td> <td><a href=\"{{url_for('articulos_delete',id=art.id)}}\"><span class=\"glyphicon glyphicon-trash\"></span> Borrar</a></td> {% endif %} {% if current_user.is_authenticated %} <td><a href=\"#\"><span class=\"glyphicon glyphicon-shopping-cart\"></span> Comprar</a></td> {% endif %} C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"7.4. Gesti\u00f3n de Usuarios con Flask-login"},{"location":"7_4_gestion_usu_flask_login.html#gestion-de-usuarios-con-extension-flask-login","text":"En las unidades anteriores hemos gestionado las sesiones con Flask de manera manual, gestionando las variables de sesi\u00f3n (fichero login.py ) directamente y comprobando su existencia para el control de acceso. En esta unidad vamos a introducir una nueva extensi\u00f3n de Flask que nos permite trabajar con sesiones: Flask-Login . \u02cbFlask-Login\u02cb es una librer\u00eda que nos proporciona la posibilidad de gestionar las sesiones de nuestros usuarios; se ocupa de las tareas comunes: como el inicio de sesi\u00f3n, logout y recordar las sesiones de los usuarios durante periodos de tiempo personalizados. Con esta extensi\u00f3n podemos almacenar el identificador de la sesi\u00f3n del usuario activo, y nos permite abrir o cerrar una sesi\u00f3n, nos permite restringir vistas o rutas a usuarios sin sesi\u00f3n activa. Con esta extensi\u00f3n no podemos restringir el comportamiento de una vista seg\u00fan el rol de usuario.","title":"Gesti\u00f3n de usuarios con extensi\u00f3n Flask-Login"},{"location":"7_4_gestion_usu_flask_login.html#instalacion-y-configuracion-de-flask-login","text":"Con nuestro entorno virtual activado: pip install Flask-Login En el programa principal configuramos la extensi\u00f3n: from flask_login import LoginManager,login_user,logout_user,login_required,current_user ... login_manager = LoginManager() login_manager.init_app(app) login_manager.login_view = \"login\" Flask-Login nos provee de diversas funciones muy interesantes para el uso de sesiones y a continuaci\u00f3n te presento las m\u00e1s interesantes: login_user : Esta funci\u00f3n permite crear la sesi\u00f3n de un usuario. logout_user : Esta funci\u00f3n permite terminar la sesi\u00f3n actual. login_required : Es un decorador que nos permite restringir la ejecuci\u00f3n de una vista s\u00f3lo a los usuarios logueados. current_user : Es un objeto con la informaci\u00f3n del usuario autentificado.","title":"Instalaci\u00f3n y configuraci\u00f3n de flask-login"},{"location":"7_4_gestion_usu_flask_login.html#revisando-el-modelo-de-datos","text":"En el modelo de datos que representa los usuarios hay que a\u00f1adirle los siguiente nuevos m\u00e9todos: def is_authenticated(self): return True def is_active(self): return True def is_anonymous(self): return False def get_id(self): return str(self.id) def is_admin(self): return self.admin is_authenticated : Devuelve \"True\" si el usuario se autentifica, es decir, que ha proporcionado unas credenciales v\u00e1lidas. is_active : Devuelve \"True\" si el usuario se encuentra activo. Adem\u00e1s de ser autenticado, tambi\u00e9n han activado su cuenta, no se ha suspendido, o cualquier condici\u00f3n que su aplicaci\u00f3n requiera para rechazar una cuenta. Esto no lo hemos tenido en cuenta en nuestro modelo de datos. is_anonymous : Retorna \"True\" si se detecta que es la sesi\u00f3n de usuario an\u00f3nimo. La respuesta es \"False\" cuando se detecta que es un usuario con unas sesi\u00f3n correcta. get_id : Nos devuelve una cadena en Unicode que identifica de forma \u00fanica a un usuario logueado en el sistema. is_admin : devuelve \"True\" si el usuario logueado es administrador.","title":"Revisando el modelo de datos"},{"location":"7_4_gestion_usu_flask_login.html#llamando-al-cargador-de-user","text":"La extensi\u00f3n Flask-Login no nos permite acceder directamente a la tabla de usuarios para obtener la informaci\u00f3n de un determinado usuario, por lo tanto en el programa principal tenemos que escribir una funci\u00f3n que va a utilizar Flask-Login: @login_manager.user_loader def load_user(user_id): return Usuarios.query.get(int(user_id))","title":"Llamando al cargador de User"},{"location":"7_4_gestion_usu_flask_login.html#control-de-acceso","text":"Por ejemplo, para poder cambiar la contrase\u00f1a el usuario tiene que estar logueado, para restringir el acceso utilizamos el decorador login_required : @app.route('/changepassword/<username>', methods=[\"get\",\"post\"]) @login_required def ... Sin embrgo si queremos restringuir por el rol, por ejemplo: la ruta /articulos/new que nos permite a\u00f1adir un videojuego s\u00f3lo se deber\u00eda permitir a los usuarios adminitradores, deber\u00e1imos codificarlo de la siguiente manera: @app.route('/articulos/new', methods=[\"get\",\"post\"]) @login_required def articulos_new(): if not current_user.is_admin(): abort(404) Otro ejemplo, s\u00f3lo podemos registrarnos si no estamos con un usuario logueado, por lo tento en la ruta registro preguntamos: @app.route(\"/registro\",methods=[\"get\",\"post\"]) def registro(): if current_user.is_authenticated: return redirect(url_for(\"inicio\"))","title":"Control de acceso"},{"location":"7_4_gestion_usu_flask_login.html#generando-contenido-segun-el-tipo-de-usuario","text":"Adem\u00e1s del control de acceso anterior tenemos que hacer que las plantillas generen contenido distintos seg\u00fan el tipo de usuario que tengamos en el sistema. Por ejemplo, s\u00f3lo le debemos mostrar el enlace de a\u00f1adir videojuegos a los usuarios administradores, para ello en la plantilla inicio.html : {% if current_user.is_authentificated and current_user.is_admin() %} <a class=\"btn btn-primary\" href=\"{{url_for('articulos_new')}}\" role=\"button\">Nuevo videojuego</a> {% endif %} Otro ejemplo, mostramos la opci\u00f3n de \"Registro\" y \"Login\" para los usuarios invitados, y la opci\u00f3n de \"Perfil\" y de \"Salir\" para los usuarios logueados, para ello en la plantilla base.html : {% if current_user.is_authenticated %} <a class=\"navbar-brand \" href=\"/perfil/{{ session[\"username\"]}}\"> Perfil</a> <a class=\"navbar-brand \" href=\"/logout\"> {{ session[\"username\"]}} (Salir)</a> {% else %} <a class=\"navbar-brand \" href=\"/login\">Login</a> <a class=\"navbar-brand \" href=\"/registro\">Registro</a> {% endif %} Para terminar con otro ejemplo, solo los administradores pueden modificar y borrar videojuegos, y los usuarios logueados pueden comprar, en la plantilla inicio.html tenemos el siguiente c\u00f3digo: {% if current_user.is_authentificated and current_user.is_admin() %} <td><a href=\"{{url_for('articulos_edit',id=art.id)}}\"><span class=\"glyphicon glyphicon-pencil\"></span> Modificar</a></td> <td><a href=\"{{url_for('articulos_delete',id=art.id)}}\"><span class=\"glyphicon glyphicon-trash\"></span> Borrar</a></td> {% endif %} {% if current_user.is_authenticated %} <td><a href=\"#\"><span class=\"glyphicon glyphicon-shopping-cart\"></span> Comprar</a></td> {% endif %}","title":"Generando contenido seg\u00fan el tipo de usuario"},{"location":"7_4_gestion_usu_flask_login.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"8_1_cookies_carrito.html","text":"Uso de cookies para a\u00f1adir art\u00edculos al carrito \u00b6 Las cookie son ficheros de texto con informaci\u00f3n, que el navegador guarda en memoria o en el disco duro, a solicitud del servidor. Manejo de cokies en flask \u00b6 En flask tenemos que generar una respuesta HTTP que solicite la creaci\u00f3n de una cookie en el cliente, para crear una cookie habr\u00e1 que indicar un nombre y el valor (cadena de caracteres) que se guarda. De forma generar: @app.route('/set_cookie') def cookie_insertion(): redirect_to_index = redirect('/index') response = current_app.make_response(redirect_to_index ) response.set_cookie('cookie_name',value='values') return response En este caso realizamos una redirecci\u00f3n guardando una cookie en el navegador. Para leer la informaci\u00f3n de una cokkie utilizaremos la siguiente instrucci\u00f3n: datos = request.cookies.get('cookie_name') Para borrar una cookie lo haremos de la siguiente manera: response.set_cookie('cookie_name',value='',expires=0) Creaci\u00f3n del carrito de compra con cookies \u00b6 En nuestro ejemplo vamos a guardar los datos del carrito de la compra en una cookie. Cuando compremos un videojuego vamos a indicar la cantidad que vamos a comprar, y si hay suficiente stock se guardar\u00e1 dicha informaci\u00f3n en la cookie. Vamos a utilizar JSON como lenguaje de marcas para guardar la informaci\u00f3n de los art\u00edculos que vamos a\u00f1adiendo al carrito, de tal manera vamos a guardar una lista con los identificadores y la cantidad de cada art\u00edculo que vamos a comprar y el nombre que le vamos a dar a la cookie ser\u00e1 el identificardor del usuario que est\u00e1 realizando la compra. Por ejemplo, el usuario con id 1 ha comprado dos art\u00edculos: datos=[{\"cantidad\": 1, \"id\": \"1\"}, {\"cantidad\": 2, \"id\": \"2\"}] Si volvemos a seleccionar un art\u00edculo que est\u00e1 en el carrito previamente y cambiamos la cantidad habr\u00e1 que actualizar el contenido de la cookie, de la misma manera que si borramos un art\u00edculo del carrito. En python el manejo de datos JSON se hace con tipos de datos listas y diccionarios, como en la cookie hay que guardar una cadena de caracteres, utilizaremos la siguiente funci\u00f3n del m\u00f3dulo json`para convertir la lista de diccionarios en cadena de caracteres: json.dumps(datos) Por ejemplo para crear una cookie con los datos de los art\u00edculos: resp.set_cookie(str(current_user.id),json.dumps(datos)) De forma similar cuando leemos la informaci\u00f3n de la cookie que es una cadena de caracteres y la queremos convertir a listas y diccionarios, utilizaremos la siguiente funci\u00f3n: json.loads(cadena) Por lo tanto para leer la informaci\u00f3n de la cookie: datos = json.loads(request.cookies.get(str(current_user.id))) A\u00f1adir art\u00edculos al carrito de la compra \u00b6 Hemos creado una nueva ruta /carrito/add/<id> que recibe el identificador del art\u00edculo comprado (se ha a\u00f1adido un enlace en el template inicio.html ). Y realiza las siguiente acciones: Muestra el formulario formCarrito para indicar la cantidad de art\u00edculos que vamos a comprar. Si la cantidad indicada es menor que la cantidad de art\u00edculos que tenemos guardado en la base de datos, se lee la informaci\u00f3n anterior de la cookie. Ahora pueden pasar dos cosas: si el art\u00edculo ya exist\u00eda en los datos de la cookie hay que actualizar el campo cantidad del diccionario, si el art\u00edculo no existe se a\u00f1ade un nuevo diccionario en la lista. Finalmente se crea una nueva cookie con la informaci\u00f3n actualizada. El c\u00f3digo ser\u00e1 el siguiente: @app.route('/carrito/add/<id>',methods=[\"get\",\"post\"]) @login_required def carrito_add(id): art=Articulos.query.get(id) form=formCarrito() form.id.data=id if form.validate_on_submit(): if art.stock>=int(form.cantidad.data): try: datos = json.loads(request.cookies.get(str(current_user.id))) except: datos = [] actualizar= False for dato in datos: if dato[\"id\"]==id: dato[\"cantidad\"]=form.cantidad.data actualizar = True if not actualizar: datos.append({\"id\":form.id.data,\"cantidad\":form.cantidad.data}) resp = make_response(redirect(url_for('inicio'))) resp.set_cookie(str(current_user.id),json.dumps(datos)) return resp form.cantidad.errors.append(\"No hay art\u00edculos suficientes.\") return render_template(\"carrito_add.html\",form=form,art=art) Mostrar los art\u00edculos del carrito \u00b6 Hemos creado una ruta /carrito , que nos muestra los art\u00edculos que hemos a\u00f1adido al carrito. Vamos a leer los datos de la cookie. Recorremos los diccionarios de la lista, y vamos guardando cada objeto Articulos y la cantidad de cada uno de ellos que vamos a comprar. Vamos acumulando el precio total de la compra. Finalmente mandamos esta informaci\u00f3n a la plantilla carrito.html para que muestre la informaci\u00f3n. El c\u00f3digo ser\u00e1 el siguiente: @app.route('/carrito') @login_required def carrito(): try: datos = json.loads(request.cookies.get(str(current_user.id))) except: datos = [] articulos=[] cantidades=[] total=0 for articulo in datos: articulos.append(Articulos.query.get(articulo[\"id\"])) cantidades.append(articulo[\"cantidad\"]) total=total+Articulos.query.get(articulo[\"id\"]).precio_final()*articulo[\"cantidad\"] articulos=zip(articulos,cantidades) return render_template(\"carrito.html\",articulos=articulos,total=total) Por otro lado hemos creado una variable num_articulos en el contexto de las plantillas, para que podamos acceder al n\u00famero de art\u00edculos que hay en el carrito desde las plantilla, para eso: @app.context_processor def contar_carrito(): if not current_user.is_authenticated: return {'num_articulos':0} if request.cookies.get(str(current_user.id))==None: return {'num_articulos':0} else: datos = json.loads(request.cookies.get(str(current_user.id))) return {'num_articulos':len(datos)} Y en la cabecera de la p\u00e1gina, plantilla base.html hemos a\u00f1adido un contado de art\u00edculos: <a class=\"navbar-brand \" href=\"/carrito\"> Carrito <span class=\"badge\">{{num_articulos}} </span></a> Borrar art\u00edculos del carrito \u00b6 Hemos a\u00f1adido un enlace en la plantilla carrito.html que nos permite borrar un art\u00edculo del carrito. dicho enlace nos lleva a la ruta /carrito_delete/<id> que realizar\u00e1 las siguientes acciones: Vamos a leer los datos de la cookie. Para borrar el diccionario correspondiente al identificador que hemos recibido, vamos a crear otra lista sin dicho diccionario. Finalmente vamos a guardar en la cookie la nueva lista. El c\u00f3digo ser\u00e1 el siguiente: @app.route('/carrito_delete/<id>') @login_required def carrito_delete(id): try: datos = json.loads(request.cookies.get(str(current_user.id))) except: datos = [] new_datos=[] for dato in datos: if dato[\"id\"]!=id: new_datos.append(dato) resp = make_response(redirect(url_for('carrito'))) resp.set_cookie(str(current_user.id),json.dumps(new_datos)) return resp C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"8.1 Uso de cookies para a\u00f1adir art\u00edculos al carrito"},{"location":"8_1_cookies_carrito.html#uso-de-cookies-para-anadir-articulos-al-carrito","text":"Las cookie son ficheros de texto con informaci\u00f3n, que el navegador guarda en memoria o en el disco duro, a solicitud del servidor.","title":"Uso de cookies para a\u00f1adir art\u00edculos al carrito"},{"location":"8_1_cookies_carrito.html#manejo-de-cokies-en-flask","text":"En flask tenemos que generar una respuesta HTTP que solicite la creaci\u00f3n de una cookie en el cliente, para crear una cookie habr\u00e1 que indicar un nombre y el valor (cadena de caracteres) que se guarda. De forma generar: @app.route('/set_cookie') def cookie_insertion(): redirect_to_index = redirect('/index') response = current_app.make_response(redirect_to_index ) response.set_cookie('cookie_name',value='values') return response En este caso realizamos una redirecci\u00f3n guardando una cookie en el navegador. Para leer la informaci\u00f3n de una cokkie utilizaremos la siguiente instrucci\u00f3n: datos = request.cookies.get('cookie_name') Para borrar una cookie lo haremos de la siguiente manera: response.set_cookie('cookie_name',value='',expires=0)","title":"Manejo de cokies en flask"},{"location":"8_1_cookies_carrito.html#creacion-del-carrito-de-compra-con-cookies","text":"En nuestro ejemplo vamos a guardar los datos del carrito de la compra en una cookie. Cuando compremos un videojuego vamos a indicar la cantidad que vamos a comprar, y si hay suficiente stock se guardar\u00e1 dicha informaci\u00f3n en la cookie. Vamos a utilizar JSON como lenguaje de marcas para guardar la informaci\u00f3n de los art\u00edculos que vamos a\u00f1adiendo al carrito, de tal manera vamos a guardar una lista con los identificadores y la cantidad de cada art\u00edculo que vamos a comprar y el nombre que le vamos a dar a la cookie ser\u00e1 el identificardor del usuario que est\u00e1 realizando la compra. Por ejemplo, el usuario con id 1 ha comprado dos art\u00edculos: datos=[{\"cantidad\": 1, \"id\": \"1\"}, {\"cantidad\": 2, \"id\": \"2\"}] Si volvemos a seleccionar un art\u00edculo que est\u00e1 en el carrito previamente y cambiamos la cantidad habr\u00e1 que actualizar el contenido de la cookie, de la misma manera que si borramos un art\u00edculo del carrito. En python el manejo de datos JSON se hace con tipos de datos listas y diccionarios, como en la cookie hay que guardar una cadena de caracteres, utilizaremos la siguiente funci\u00f3n del m\u00f3dulo json`para convertir la lista de diccionarios en cadena de caracteres: json.dumps(datos) Por ejemplo para crear una cookie con los datos de los art\u00edculos: resp.set_cookie(str(current_user.id),json.dumps(datos)) De forma similar cuando leemos la informaci\u00f3n de la cookie que es una cadena de caracteres y la queremos convertir a listas y diccionarios, utilizaremos la siguiente funci\u00f3n: json.loads(cadena) Por lo tanto para leer la informaci\u00f3n de la cookie: datos = json.loads(request.cookies.get(str(current_user.id)))","title":"Creaci\u00f3n del carrito de compra con cookies"},{"location":"8_1_cookies_carrito.html#anadir-articulos-al-carrito-de-la-compra","text":"Hemos creado una nueva ruta /carrito/add/<id> que recibe el identificador del art\u00edculo comprado (se ha a\u00f1adido un enlace en el template inicio.html ). Y realiza las siguiente acciones: Muestra el formulario formCarrito para indicar la cantidad de art\u00edculos que vamos a comprar. Si la cantidad indicada es menor que la cantidad de art\u00edculos que tenemos guardado en la base de datos, se lee la informaci\u00f3n anterior de la cookie. Ahora pueden pasar dos cosas: si el art\u00edculo ya exist\u00eda en los datos de la cookie hay que actualizar el campo cantidad del diccionario, si el art\u00edculo no existe se a\u00f1ade un nuevo diccionario en la lista. Finalmente se crea una nueva cookie con la informaci\u00f3n actualizada. El c\u00f3digo ser\u00e1 el siguiente: @app.route('/carrito/add/<id>',methods=[\"get\",\"post\"]) @login_required def carrito_add(id): art=Articulos.query.get(id) form=formCarrito() form.id.data=id if form.validate_on_submit(): if art.stock>=int(form.cantidad.data): try: datos = json.loads(request.cookies.get(str(current_user.id))) except: datos = [] actualizar= False for dato in datos: if dato[\"id\"]==id: dato[\"cantidad\"]=form.cantidad.data actualizar = True if not actualizar: datos.append({\"id\":form.id.data,\"cantidad\":form.cantidad.data}) resp = make_response(redirect(url_for('inicio'))) resp.set_cookie(str(current_user.id),json.dumps(datos)) return resp form.cantidad.errors.append(\"No hay art\u00edculos suficientes.\") return render_template(\"carrito_add.html\",form=form,art=art)","title":"A\u00f1adir art\u00edculos al carrito de la compra"},{"location":"8_1_cookies_carrito.html#mostrar-los-articulos-del-carrito","text":"Hemos creado una ruta /carrito , que nos muestra los art\u00edculos que hemos a\u00f1adido al carrito. Vamos a leer los datos de la cookie. Recorremos los diccionarios de la lista, y vamos guardando cada objeto Articulos y la cantidad de cada uno de ellos que vamos a comprar. Vamos acumulando el precio total de la compra. Finalmente mandamos esta informaci\u00f3n a la plantilla carrito.html para que muestre la informaci\u00f3n. El c\u00f3digo ser\u00e1 el siguiente: @app.route('/carrito') @login_required def carrito(): try: datos = json.loads(request.cookies.get(str(current_user.id))) except: datos = [] articulos=[] cantidades=[] total=0 for articulo in datos: articulos.append(Articulos.query.get(articulo[\"id\"])) cantidades.append(articulo[\"cantidad\"]) total=total+Articulos.query.get(articulo[\"id\"]).precio_final()*articulo[\"cantidad\"] articulos=zip(articulos,cantidades) return render_template(\"carrito.html\",articulos=articulos,total=total) Por otro lado hemos creado una variable num_articulos en el contexto de las plantillas, para que podamos acceder al n\u00famero de art\u00edculos que hay en el carrito desde las plantilla, para eso: @app.context_processor def contar_carrito(): if not current_user.is_authenticated: return {'num_articulos':0} if request.cookies.get(str(current_user.id))==None: return {'num_articulos':0} else: datos = json.loads(request.cookies.get(str(current_user.id))) return {'num_articulos':len(datos)} Y en la cabecera de la p\u00e1gina, plantilla base.html hemos a\u00f1adido un contado de art\u00edculos: <a class=\"navbar-brand \" href=\"/carrito\"> Carrito <span class=\"badge\">{{num_articulos}} </span></a>","title":"Mostrar los art\u00edculos del carrito"},{"location":"8_1_cookies_carrito.html#borrar-articulos-del-carrito","text":"Hemos a\u00f1adido un enlace en la plantilla carrito.html que nos permite borrar un art\u00edculo del carrito. dicho enlace nos lleva a la ruta /carrito_delete/<id> que realizar\u00e1 las siguientes acciones: Vamos a leer los datos de la cookie. Para borrar el diccionario correspondiente al identificador que hemos recibido, vamos a crear otra lista sin dicho diccionario. Finalmente vamos a guardar en la cookie la nueva lista. El c\u00f3digo ser\u00e1 el siguiente: @app.route('/carrito_delete/<id>') @login_required def carrito_delete(id): try: datos = json.loads(request.cookies.get(str(current_user.id))) except: datos = [] new_datos=[] for dato in datos: if dato[\"id\"]!=id: new_datos.append(dato) resp = make_response(redirect(url_for('carrito'))) resp.set_cookie(str(current_user.id),json.dumps(new_datos)) return resp","title":"Borrar art\u00edculos del carrito"},{"location":"8_1_cookies_carrito.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"8_2_finalizar_compra.html","text":"Finalizaci\u00f3n de la compra \u00b6 En esta \u00faltima unidad vamos a simular el final de la compra, en este caso hemos simplificado mucho este proceso, simplemente vamos a mostrar la lista de los art\u00edculos comprados, el precio final y vamos a actualizar el stock de cada uno de los art\u00edculos. Realizar pedido \u00b6 En la plantilla carrito.hrml hemos introducido un enlace al la ruta pedido : <a class=\"btn btn-primary\" href=\"{{url_for('pedido')}}\" role=\"button\">Comprar</a> En esta ruta vamos a realizar las siguientes acciones: Vamos a leer los datos de la cookie Calculamos el precio final de la compra. Actualizamos en cada art\u00edculo la cantidad restando los art\u00edculos que hemos comprado. Borramos la cookie Utilizando la plantilla pedido.html mostramos los art\u00edculos y el precio final. El c\u00f3digo quedar\u00eda de la siguiente forma: @app.route('/pedido') @login_required def pedido(): try: datos = json.loads(request.cookies.get(str(current_user.id))) except: datos = [] total=0 for articulo in datos: total=total+Articulos.query.get(articulo[\"id\"]).precio_final()*articulo[\"cantidad\"] Articulos.query.get(articulo[\"id\"]).stock-=articulo[\"cantidad\"] db.session.commit() resp = make_response(render_template(\"pedido.html\",total=total)) resp.set_cookie(str(current_user.id),\"\",expires=0) return resp C\u00f3digo ejemplo de esta unidad \u00b6 C\u00f3digo","title":"8.2 Finalizaci\u00f3n de la compra"},{"location":"8_2_finalizar_compra.html#finalizacion-de-la-compra","text":"En esta \u00faltima unidad vamos a simular el final de la compra, en este caso hemos simplificado mucho este proceso, simplemente vamos a mostrar la lista de los art\u00edculos comprados, el precio final y vamos a actualizar el stock de cada uno de los art\u00edculos.","title":"Finalizaci\u00f3n de la compra"},{"location":"8_2_finalizar_compra.html#realizar-pedido","text":"En la plantilla carrito.hrml hemos introducido un enlace al la ruta pedido : <a class=\"btn btn-primary\" href=\"{{url_for('pedido')}}\" role=\"button\">Comprar</a> En esta ruta vamos a realizar las siguientes acciones: Vamos a leer los datos de la cookie Calculamos el precio final de la compra. Actualizamos en cada art\u00edculo la cantidad restando los art\u00edculos que hemos comprado. Borramos la cookie Utilizando la plantilla pedido.html mostramos los art\u00edculos y el precio final. El c\u00f3digo quedar\u00eda de la siguiente forma: @app.route('/pedido') @login_required def pedido(): try: datos = json.loads(request.cookies.get(str(current_user.id))) except: datos = [] total=0 for articulo in datos: total=total+Articulos.query.get(articulo[\"id\"]).precio_final()*articulo[\"cantidad\"] Articulos.query.get(articulo[\"id\"]).stock-=articulo[\"cantidad\"] db.session.commit() resp = make_response(render_template(\"pedido.html\",total=total)) resp.set_cookie(str(current_user.id),\"\",expires=0) return resp","title":"Realizar pedido"},{"location":"8_2_finalizar_compra.html#codigo-ejemplo-de-esta-unidad","text":"C\u00f3digo","title":"C\u00f3digo ejemplo de esta unidad"},{"location":"9_1_desplegar_lamp.html","text":"Despliegue de aplicaci\u00f3n flask en un servidor LAMP \u00b6 Vamos a desplegar nuestra aplicaci\u00f3n web desarrollada con flask en un servidor LAMP (Linux+Apache2+mysql+python) en un sistema operativo GNU/Linux Ubuntu 16.04. Configuraci\u00f3n del servidor \u00b6 Despu\u00e9s de actualizar los paquetes del sistema: $ sudo apt-get update $ sudo apt-get upgrade Hacemos la instalaci\u00f3n del servidor web y del servidor de bases de datos: $ sudo apt-get install apache2 mysql-server libapache2-mod-wsgi-py3 Configuraci\u00f3n de la base de datos \u00b6 Vamos a crear un usuario y una base de datos con la que vamos a a trabajar: $ mysql -u root -p mysql> create database tienda; mysql> GRANT ALL ON tienda.* TO usuario IDENTIFIED BY 'usuario'; Adem\u00e1s vamos a configurar nuestra aplicaci\u00f3n para que trabaje con mysql, para ello en el fichero aplicacion\\config.py modificamos el motor de base de datos con el que vamos a trabajar, indicando las credenciales del usuario y la base de datos: SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://ususario:usuario@localhost/tienda' Por \u00faltimo a\u00f1adimos en el fichero requirements.txt el paquete que me permite que python trabaje con mysql: ... PyMySQL==0.7.11 Despliegue de la aplicaci\u00f3n: \u00b6 clonamos la rama lamp del repositorio: https://github.com/josedom24/tienda_videojuegos.git , lo hacemos como superusuario en el directorio /var/www/html : $ sudo su - $ cd /var/www/html $ git clone https://github.com/josedom24/tienda_videojuegos.git -b lamp Como usuario sin privilegios vamos a crear un entorno virtual, donde vamos a instalar las dependencias de nuestra aplicaci\u00f3n: $ sudo apt-get install python-virtualenv $ mkdir venv $ cd venv/ ~/venv$ virtualenv -p /usr/bin/python3 flask ~/venv$ source flask/bin/activate (flask) ~/venv$ pip install -r /var/www/html/tienda_videojuegos/requirements.txt Creamos las tablas, a\u00f1adimos los datos de ejemplo y creamos al usuario administrador: (flask)$ cd /var/www/html/tienda_videojuegos (flask)$ python3 manage.py create_tables (flask)$ python3 manage.py add_data_tables (flask)$ python3 manage.py create_admin En el directorio /var/www/html/tienda_viedojuegos hemos creado nuestra aplicaci\u00f3n WSGI en el fichero app.wsgi , donde activamos el entorno virtual que hemos creado: import sys sys.path.insert(0, '/var/www/html/tienda_videojuegos') activate_this = '/home/ubuntu/venv/flask/bin/activate_this.py' with open(activate_this) as file_: exec(file_.read(), dict(__file__=activate_this)) from aplicacion.app import app as application Por \u00faltimo configuramos apache2 modificando el virtualhost del fichero \u02cb/etc/apache2/sites-available/000-default.conf\u02cb: ... DocumentRoot /var/www/html/tienda_videojuegos/aplicacion WSGIDaemonProcess tienda user=www-data group=www-data threads=5 WSGIScriptAlias / /var/www/html/tienda_videojuegos/app.wsgi <Directory /var/www/html/tienda_videojuegos/aplicacion> WSGIProcessGroup tienda WSGIApplicationGroup %{GLOBAL} Require all granted </Directory> ... Donde definimos el proceso WSGI con la directiva WSGIDaemonProcess e indicamos el fichero donde se encuentra la aplicaci\u00f3n WSGI con la directiva WSGISrctiptAlias , adem\u00e1s de dar los permisos de acceso necesarios. Terminamos reiniciando el servidor: $ sudo systemctl restart apache2 Y probamos el acceso a la aplicaci\u00f3n:","title":"9.1 Despliegue de aplicaci\u00f3n flask en un servidor LAMP"},{"location":"9_1_desplegar_lamp.html#despliegue-de-aplicacion-flask-en-un-servidor-lamp","text":"Vamos a desplegar nuestra aplicaci\u00f3n web desarrollada con flask en un servidor LAMP (Linux+Apache2+mysql+python) en un sistema operativo GNU/Linux Ubuntu 16.04.","title":"Despliegue de aplicaci\u00f3n flask en un servidor LAMP"},{"location":"9_1_desplegar_lamp.html#configuracion-del-servidor","text":"Despu\u00e9s de actualizar los paquetes del sistema: $ sudo apt-get update $ sudo apt-get upgrade Hacemos la instalaci\u00f3n del servidor web y del servidor de bases de datos: $ sudo apt-get install apache2 mysql-server libapache2-mod-wsgi-py3","title":"Configuraci\u00f3n del servidor"},{"location":"9_1_desplegar_lamp.html#configuracion-de-la-base-de-datos","text":"Vamos a crear un usuario y una base de datos con la que vamos a a trabajar: $ mysql -u root -p mysql> create database tienda; mysql> GRANT ALL ON tienda.* TO usuario IDENTIFIED BY 'usuario'; Adem\u00e1s vamos a configurar nuestra aplicaci\u00f3n para que trabaje con mysql, para ello en el fichero aplicacion\\config.py modificamos el motor de base de datos con el que vamos a trabajar, indicando las credenciales del usuario y la base de datos: SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://ususario:usuario@localhost/tienda' Por \u00faltimo a\u00f1adimos en el fichero requirements.txt el paquete que me permite que python trabaje con mysql: ... PyMySQL==0.7.11","title":"Configuraci\u00f3n de la base de datos"},{"location":"9_1_desplegar_lamp.html#despliegue-de-la-aplicacion","text":"clonamos la rama lamp del repositorio: https://github.com/josedom24/tienda_videojuegos.git , lo hacemos como superusuario en el directorio /var/www/html : $ sudo su - $ cd /var/www/html $ git clone https://github.com/josedom24/tienda_videojuegos.git -b lamp Como usuario sin privilegios vamos a crear un entorno virtual, donde vamos a instalar las dependencias de nuestra aplicaci\u00f3n: $ sudo apt-get install python-virtualenv $ mkdir venv $ cd venv/ ~/venv$ virtualenv -p /usr/bin/python3 flask ~/venv$ source flask/bin/activate (flask) ~/venv$ pip install -r /var/www/html/tienda_videojuegos/requirements.txt Creamos las tablas, a\u00f1adimos los datos de ejemplo y creamos al usuario administrador: (flask)$ cd /var/www/html/tienda_videojuegos (flask)$ python3 manage.py create_tables (flask)$ python3 manage.py add_data_tables (flask)$ python3 manage.py create_admin En el directorio /var/www/html/tienda_viedojuegos hemos creado nuestra aplicaci\u00f3n WSGI en el fichero app.wsgi , donde activamos el entorno virtual que hemos creado: import sys sys.path.insert(0, '/var/www/html/tienda_videojuegos') activate_this = '/home/ubuntu/venv/flask/bin/activate_this.py' with open(activate_this) as file_: exec(file_.read(), dict(__file__=activate_this)) from aplicacion.app import app as application Por \u00faltimo configuramos apache2 modificando el virtualhost del fichero \u02cb/etc/apache2/sites-available/000-default.conf\u02cb: ... DocumentRoot /var/www/html/tienda_videojuegos/aplicacion WSGIDaemonProcess tienda user=www-data group=www-data threads=5 WSGIScriptAlias / /var/www/html/tienda_videojuegos/app.wsgi <Directory /var/www/html/tienda_videojuegos/aplicacion> WSGIProcessGroup tienda WSGIApplicationGroup %{GLOBAL} Require all granted </Directory> ... Donde definimos el proceso WSGI con la directiva WSGIDaemonProcess e indicamos el fichero donde se encuentra la aplicaci\u00f3n WSGI con la directiva WSGISrctiptAlias , adem\u00e1s de dar los permisos de acceso necesarios. Terminamos reiniciando el servidor: $ sudo systemctl restart apache2 Y probamos el acceso a la aplicaci\u00f3n:","title":"Despliegue de la aplicaci\u00f3n:"},{"location":"9_2_desplegar_anywhere.html","text":"Despliegue de aplicaci\u00f3n flask en hosting pythonanywhere \u00b6 En este ejemplo vamos a desplegar nuestra aplicaci\u00f3n en un hosting que nos permite trabajar con python llamado PythonAnywhere , que nos ofrece distintos planes de contrataci\u00f3n , aunque nosotros vamos a usar el Beginner que es gratuito y para aplicaciones de prueba con pocos accesos es suficiente. Configuraci\u00f3n de la base de datos \u00b6 PythonAnywhere nos da la posibilidad de trabajar con mysql y con postgres. En nuestro caso en la pesta\u00f1a Databases del dashboard, vamos a crear una base de datos mysql con una base de datos: josedom24$tienda : Por lo tanto tendremos que configurar nuestra aplicaci\u00f3n, para indicar la nuevas credenciales de la base de datos, para ello modificamos el fichero confi.py : SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://josedom24:usuario1234@josedom24.mysql.pythonanywhere-services.com/josedom24$tienda' Configuraci\u00f3n de nuestra aplicaci\u00f3n \u00b6 En este ejemplo vamos a modificar el fichero app.wsgi para indicar el directorio de trabajo, adem\u00e1s no vamos activar el entrono virtual: import sys sys.path.insert(0, '/home/josedom24/tienda_videojuegos') from aplicacion.app import app as application Despliegue de nuestra aplicaci\u00f3n \u00b6 En la pesta\u00f1a Consoles de PythonAnywhere podemos abrir consolas con los distintos interpretes python, con bash o con mysql, vamos a abrir una consola bash para comenzar el despliegue: Vamos a clonar nuestro repositorio, crear un repositorio e instalar las dependencias: $ git clone https://github.com/josedom24/tienda_videojuegos.git -b pythonanywhere $ mkvirtualenv --python=/usr/bin/python3.4 flask $ workon flask (flask)$ pip install -r tienda_videojuegos/requirements.txt A continuaci\u00f3n podemos crear las tablas, cargar los datos de ejemplo y crear el administrador: (flask)$ cd tienda_videojuegos (flask)$ python3 manage.py create_tables (flask)$ python3 manage.py add_data_tables (flask)$ python3 manage.py create_admin Nota: Si queremos modificar cualquier fichero de nuestro proyecto lo podemos hacer desde la pesta\u00f1a Files . Creando una nueva aplicaci\u00f3n \u00b6 Por \u00faltimo en la pesta\u00f1a Web tenemos que crear una nueva aplicaci\u00f3n: Elegimos la opci\u00f3n \"Manual configuration\" para poder indicar el entorno virtual que hemos creado: Elegimos la versi\u00f3n de python (en este caso la misma con la que hemos creado el entorno virtual, python 3.4) y ya tenemos la aplicaci\u00f3n creada. S\u00f3lo nos queda indicar la ruta donde se encuentra nuetro entorno virtual, en la secci\u00f3n Virtualenv : Y modificar el fichero /var/www/josedom24_pythonanywhere_com_wsgi.py en el apartado \"WSGI configuration file:\" de la secci\u00f3n \"Code\": Por \u00faltimo reiniciamos el servidor pulsando el bot\u00f3n \"Reload ...\" y accedemos a la p\u00e1gina:","title":"9.2 Despliegue de aplicaci\u00f3n flask en hosting pythonanywhere"},{"location":"9_2_desplegar_anywhere.html#despliegue-de-aplicacion-flask-en-hosting-pythonanywhere","text":"En este ejemplo vamos a desplegar nuestra aplicaci\u00f3n en un hosting que nos permite trabajar con python llamado PythonAnywhere , que nos ofrece distintos planes de contrataci\u00f3n , aunque nosotros vamos a usar el Beginner que es gratuito y para aplicaciones de prueba con pocos accesos es suficiente.","title":"Despliegue de aplicaci\u00f3n flask en hosting pythonanywhere"},{"location":"9_2_desplegar_anywhere.html#configuracion-de-la-base-de-datos","text":"PythonAnywhere nos da la posibilidad de trabajar con mysql y con postgres. En nuestro caso en la pesta\u00f1a Databases del dashboard, vamos a crear una base de datos mysql con una base de datos: josedom24$tienda : Por lo tanto tendremos que configurar nuestra aplicaci\u00f3n, para indicar la nuevas credenciales de la base de datos, para ello modificamos el fichero confi.py : SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://josedom24:usuario1234@josedom24.mysql.pythonanywhere-services.com/josedom24$tienda'","title":"Configuraci\u00f3n de la base de datos"},{"location":"9_2_desplegar_anywhere.html#configuracion-de-nuestra-aplicacion","text":"En este ejemplo vamos a modificar el fichero app.wsgi para indicar el directorio de trabajo, adem\u00e1s no vamos activar el entrono virtual: import sys sys.path.insert(0, '/home/josedom24/tienda_videojuegos') from aplicacion.app import app as application","title":"Configuraci\u00f3n de nuestra aplicaci\u00f3n"},{"location":"9_2_desplegar_anywhere.html#despliegue-de-nuestra-aplicacion","text":"En la pesta\u00f1a Consoles de PythonAnywhere podemos abrir consolas con los distintos interpretes python, con bash o con mysql, vamos a abrir una consola bash para comenzar el despliegue: Vamos a clonar nuestro repositorio, crear un repositorio e instalar las dependencias: $ git clone https://github.com/josedom24/tienda_videojuegos.git -b pythonanywhere $ mkvirtualenv --python=/usr/bin/python3.4 flask $ workon flask (flask)$ pip install -r tienda_videojuegos/requirements.txt A continuaci\u00f3n podemos crear las tablas, cargar los datos de ejemplo y crear el administrador: (flask)$ cd tienda_videojuegos (flask)$ python3 manage.py create_tables (flask)$ python3 manage.py add_data_tables (flask)$ python3 manage.py create_admin Nota: Si queremos modificar cualquier fichero de nuestro proyecto lo podemos hacer desde la pesta\u00f1a Files .","title":"Despliegue de nuestra aplicaci\u00f3n"},{"location":"9_2_desplegar_anywhere.html#creando-una-nueva-aplicacion","text":"Por \u00faltimo en la pesta\u00f1a Web tenemos que crear una nueva aplicaci\u00f3n: Elegimos la opci\u00f3n \"Manual configuration\" para poder indicar el entorno virtual que hemos creado: Elegimos la versi\u00f3n de python (en este caso la misma con la que hemos creado el entorno virtual, python 3.4) y ya tenemos la aplicaci\u00f3n creada. S\u00f3lo nos queda indicar la ruta donde se encuentra nuetro entorno virtual, en la secci\u00f3n Virtualenv : Y modificar el fichero /var/www/josedom24_pythonanywhere_com_wsgi.py en el apartado \"WSGI configuration file:\" de la secci\u00f3n \"Code\": Por \u00faltimo reiniciamos el servidor pulsando el bot\u00f3n \"Reload ...\" y accedemos a la p\u00e1gina:","title":"Creando una nueva aplicaci\u00f3n"},{"location":"9_3_desplegar_heroku.html","text":"Despliegue de aplicaci\u00f3n flask en un PaaS Heroku \u00b6 En esta unidad vamos a desplegar nuestra aplicaci\u00f3n web desarrollada en python utilizando el framework flask utilizando s\u00f3lo la aplicaci\u00f3n web Heroku (Heroku Dashboard) (no vamos a utilizar el comando heroku-cli ). Heroku es una aplicaci\u00f3n que nos ofrece un servicio de Cloud Computing PaaS (Plataforma como servicio). Como leemos en la Wikipedia es propiedad de Salesforce.com y es una de las primeras plataformas de computaci\u00f3n en la nube, que fue desarrollada desde junio de 2007, con el objetivo de soportar solamente el lenguaje de programaci\u00f3n Ruby, pero posteriormente se ha extendido el soporte a Java, Node.js, Scala, Clojure y Python y PHP. La funcionalidad ofrecida por heroku esta disponible con el uso de dynos, que son una adaptaci\u00f3n de los contenedores Linux y nos ofrecen la capacidad de computo dentro de la plataforma. Vamos a utilizar la capa gratuita de Horoku: Podemos crear un dyno, que puede ejecutar un m\u00e1ximo de dos tipos de procesos. Nuestro dyno utiliza 512 Mb de RAM Tras 30 minutos de inactividad el dyno se para (sleep), adem\u00e1s debe estar parado 6 horas cada 24 horas. Podemos utilizar una base de datos postgreSQL con no m\u00e1s de 10.000 registros Para m\u00e1s informaci\u00f3n: planes ofrecido por heroku Preparativos previos \u00b6 Tenemos que crear una cuenta gratuita en Heroku (singup) En el repositorio github de nuestra aplicaci\u00f3n hemos creado un nuevo fichero: Procfile : En este fichero se define el proceso que va a ejecutar el dyno. Para m\u00e1s informaci\u00f3n: Process Types and the Procfile Creamos una nueva aplicaci\u00f3n en heroku \u00b6 Tenemos que indicar un nombre \u00fanico. La URL de nuestra aplicaci\u00f3n ser\u00e1: https://tiendavideojuegos.herokuapp.com Conectamos nuestro proyecto a GitHub \u00b6 El contenido que vamos a desplegar en nuestro proyecto se va a copiar desde el repositorio donde tenemos nuestra aplicaci\u00f3n, para ello desde la pesta\u00f1a Deploy vamos a escoger la opci\u00f3n: Connect to GitHub . A continuaci\u00f3n desde GitHub le tenemos que dar permiso a la aplicaci\u00f3n Heroku, para que accede a nuestros repositorios: Ahora tenemos que conectar el repositorio donde tenemos nuestra aplicaci\u00f3n: Tenemos a nuestra disposici\u00f3n dos maneras de hacer los despliegues: Autom\u00e1ticos: Esta opci\u00f3n la podemos habilitar. Cada vez que hagamos un commit en nuestro repositorio GitHub, heroku va a desplegar la aplicaci\u00f3n. Tenemos que elegir la rama que se va desplegar de forma autom\u00e1tica. Manual: Elegimos la rama que vamos a desplegar y pulsamos el bot\u00f3n Deploy Branch Veamos un ejemplo de despliegue manual: Y accedemos a la p\u00e1gina: Por \u00faltimo indicar que podemos ejecutar un terminal en el dyno para ejecutar cualquier instrucci\u00f3n. Para ello seleccionamos la opci\u00f3n Run console de la opci\u00f3n More y ejecutamos heroku run bash :","title":"9.3 Despliegue de aplicaci\u00f3n flask en un PaaS Heroku"},{"location":"9_3_desplegar_heroku.html#despliegue-de-aplicacion-flask-en-un-paas-heroku","text":"En esta unidad vamos a desplegar nuestra aplicaci\u00f3n web desarrollada en python utilizando el framework flask utilizando s\u00f3lo la aplicaci\u00f3n web Heroku (Heroku Dashboard) (no vamos a utilizar el comando heroku-cli ). Heroku es una aplicaci\u00f3n que nos ofrece un servicio de Cloud Computing PaaS (Plataforma como servicio). Como leemos en la Wikipedia es propiedad de Salesforce.com y es una de las primeras plataformas de computaci\u00f3n en la nube, que fue desarrollada desde junio de 2007, con el objetivo de soportar solamente el lenguaje de programaci\u00f3n Ruby, pero posteriormente se ha extendido el soporte a Java, Node.js, Scala, Clojure y Python y PHP. La funcionalidad ofrecida por heroku esta disponible con el uso de dynos, que son una adaptaci\u00f3n de los contenedores Linux y nos ofrecen la capacidad de computo dentro de la plataforma. Vamos a utilizar la capa gratuita de Horoku: Podemos crear un dyno, que puede ejecutar un m\u00e1ximo de dos tipos de procesos. Nuestro dyno utiliza 512 Mb de RAM Tras 30 minutos de inactividad el dyno se para (sleep), adem\u00e1s debe estar parado 6 horas cada 24 horas. Podemos utilizar una base de datos postgreSQL con no m\u00e1s de 10.000 registros Para m\u00e1s informaci\u00f3n: planes ofrecido por heroku","title":"Despliegue de aplicaci\u00f3n flask en un PaaS Heroku"},{"location":"9_3_desplegar_heroku.html#preparativos-previos","text":"Tenemos que crear una cuenta gratuita en Heroku (singup) En el repositorio github de nuestra aplicaci\u00f3n hemos creado un nuevo fichero: Procfile : En este fichero se define el proceso que va a ejecutar el dyno. Para m\u00e1s informaci\u00f3n: Process Types and the Procfile","title":"Preparativos previos"},{"location":"9_3_desplegar_heroku.html#creamos-una-nueva-aplicacion-en-heroku","text":"Tenemos que indicar un nombre \u00fanico. La URL de nuestra aplicaci\u00f3n ser\u00e1: https://tiendavideojuegos.herokuapp.com","title":"Creamos una nueva aplicaci\u00f3n en heroku"},{"location":"9_3_desplegar_heroku.html#conectamos-nuestro-proyecto-a-github","text":"El contenido que vamos a desplegar en nuestro proyecto se va a copiar desde el repositorio donde tenemos nuestra aplicaci\u00f3n, para ello desde la pesta\u00f1a Deploy vamos a escoger la opci\u00f3n: Connect to GitHub . A continuaci\u00f3n desde GitHub le tenemos que dar permiso a la aplicaci\u00f3n Heroku, para que accede a nuestros repositorios: Ahora tenemos que conectar el repositorio donde tenemos nuestra aplicaci\u00f3n: Tenemos a nuestra disposici\u00f3n dos maneras de hacer los despliegues: Autom\u00e1ticos: Esta opci\u00f3n la podemos habilitar. Cada vez que hagamos un commit en nuestro repositorio GitHub, heroku va a desplegar la aplicaci\u00f3n. Tenemos que elegir la rama que se va desplegar de forma autom\u00e1tica. Manual: Elegimos la rama que vamos a desplegar y pulsamos el bot\u00f3n Deploy Branch Veamos un ejemplo de despliegue manual: Y accedemos a la p\u00e1gina: Por \u00faltimo indicar que podemos ejecutar un terminal en el dyno para ejecutar cualquier instrucci\u00f3n. Para ello seleccionamos la opci\u00f3n Run console de la opci\u00f3n More y ejecutamos heroku run bash :","title":"Conectamos nuestro proyecto a GitHub"},{"location":"9_4_desplegar_docker.html","text":"Despliegue de aplicaci\u00f3n flask en un contenedor docker \u00b6 Vamos a desplegar nuestra aplicaci\u00f3n web desarrollada con flask en docker. Vamos a utilizar dos contenedores: uno para la base de datos mysql y otro para nuestra aplicaci\u00f3n. Seguimos las instrucciones de la documentaci\u00f3n de docker para realizar la instalaci\u00f3n en Ubuntu 16.04. Contenedor de base de datos \u00b6 Vamos a arrancar un contenedor que nos sirva la base de datos, indicamos la contrase\u00f1a del usuario root y creamos una base de datos: sudo docker run --name servidor_mysql -e MYSQL_DATABASE=tienda -e MYSQL_ROOT_PASSWORD=asdasd -d mysql En al configuraci\u00f3n de la conexi\u00f3n a la base de datos de nuestra aplicaci\u00f3n, en el fichero config.py tendremos que indicar los par\u00e1metros de conexi\u00f3n y la contrase\u00f1a del root de mysql que vamos a mandar cunado creemos el contenedor, de la siguiente manera: SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:{}@{}/tienda'.format(os.environ[\"MYSQL_PASSWORD\"],os.environ[\"MYSQL_PORT_3306_TCP_ADDR\"]) Creando la imagen para el contenedor de nuestra aplicaci\u00f3n \u00b6 Clonamos la rama docker del repositorio github donde tenemos los ficheros de nuestra aplicaci\u00f3n: $ git clone https://github.com/josedom24/tienda_videojuegos.git -b docker En el repositorio tenemos un fichero Dockerfile donde definimos las instrucciones que vamos a ejecutar para crear la imagen docker: FROM ubuntu:16.04 MAINTAINER Jos\u00e9 Domingo Mu\u00f1oz RUN apt-get update -y && apt-get install -y \\ apache2 \\ libapache2-mod-wsgi-py3 \\ python3-pip \\ && apt-get clean && rm -rf /var/lib/apt/lists/* ADD /tienda_videojuegos /var/www/html/tienda_videojuegos RUN chown www-data:www-data -R /var/www/html/tienda_videojuegos RUN pip3 install -r /var/www/html/tienda_videojuegos/requirements.txt ADD 000-default.conf /etc/apache2/sites-available/ ADD app.wsgi /var/www/html/tienda_videojuegos RUN service apache2 restart ENV APACHE_RUN_USER www-data ENV APACHE_RUN_GROUP www-data ENV APACHE_LOG_DIR /var/log/apache2 EXPOSE 80 WORKDIR /var/www/html/tienda_videojuegos COPY ./run.sh / ENTRYPOINT [\"/run.sh\"] Tambi\u00e9n tenemos el fichero donde creamos la aplicaci\u00f3n WSGI, app.wsgi : import sys sys.path.insert(0, '/var/www/html/tienda_videojuegos') from aplicacion.app import app as application El fichero de configuraci\u00f3n del virtualhost de apache2: 000-default.conf : ... DocumentRoot /var/www/html/tienda_videojuegos/aplicacion WSGIDaemonProcess tienda user=www-data group=www-data threads=5 WSGIScriptAlias / /var/www/html/tienda_videojuegos/app.wsgi <Directory /var/www/html/tienda_videojuegos/aplicacion> WSGIProcessGroup tienda WSGIApplicationGroup %{GLOBAL} Require all granted </Directory> ... Y por \u00faltimo el fichero run.sh que el script que se va a ejecutar cuando creemos el contenedor: #!/bin/bash python3 manage.py create_tables python3 manage.py add_data_tables /usr/sbin/apache2ctl -D FOREGROUND Creamos las tablas con los datos de ejemplo de la base de datos y ejecutamos el servidor apache2. Para crear la imagen ejecutamos el siguiente comando: $ cd tienda_videojuegos $ sudo docker build -t tienda . Y comprobamos que hemos generado la nueva imagen: $ sudo docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE tienda latest bb1d87c90448 46 hours ago 474MB ubuntu 16.04 ccc7a11d65b1 11 days ago 120MB mysql latest c73c7527c03a 3 weeks ago 412MB Contenedor con nuestra aplicaci\u00f3n \u00b6 Para crear el contenedor con nuestra aplicaci\u00f3n: $ sudo docker run --name mytienda -e MYSQL_PASSWORD=asdasd -p 8080:80 --link servidor_mysql:mysql -d tienda Comprobamos que los contenedores se est\u00e1n ejecutando: $ sudo docker ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 08eadf7d87b0 tienda \"/run.sh\" 4 seconds ago Up 3 seconds 0.0.0.0:8080->80/tcp mytienda 6ccff57702ba mysql \"docker-entrypoint...\" 16 seconds ago Up 16 seconds 3306/tcp servidor_mysql Si queremos crear el usuario administrador de nuestra aplicaci\u00f3n podemos acceder de forma interactiva a nuestro contenedor para ejecutar la instrucci\u00f3n necesaria: $ sudo docker exec -i -t mytienda /bin/bash root@5db96abf79b3:/var/www/html/tienda_videojuegos# python3 manage.py create_admin Por ultimo comprobamos que la aplicaci\u00f3n est\u00e1 funcionando accediendo a la ip del servidor y al puerto 8080:","title":"9.4 Despliegue de aplicaci\u00f3n flask en un contenedor docker"},{"location":"9_4_desplegar_docker.html#despliegue-de-aplicacion-flask-en-un-contenedor-docker","text":"Vamos a desplegar nuestra aplicaci\u00f3n web desarrollada con flask en docker. Vamos a utilizar dos contenedores: uno para la base de datos mysql y otro para nuestra aplicaci\u00f3n. Seguimos las instrucciones de la documentaci\u00f3n de docker para realizar la instalaci\u00f3n en Ubuntu 16.04.","title":"Despliegue de aplicaci\u00f3n flask en un contenedor docker"},{"location":"9_4_desplegar_docker.html#contenedor-de-base-de-datos","text":"Vamos a arrancar un contenedor que nos sirva la base de datos, indicamos la contrase\u00f1a del usuario root y creamos una base de datos: sudo docker run --name servidor_mysql -e MYSQL_DATABASE=tienda -e MYSQL_ROOT_PASSWORD=asdasd -d mysql En al configuraci\u00f3n de la conexi\u00f3n a la base de datos de nuestra aplicaci\u00f3n, en el fichero config.py tendremos que indicar los par\u00e1metros de conexi\u00f3n y la contrase\u00f1a del root de mysql que vamos a mandar cunado creemos el contenedor, de la siguiente manera: SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:{}@{}/tienda'.format(os.environ[\"MYSQL_PASSWORD\"],os.environ[\"MYSQL_PORT_3306_TCP_ADDR\"])","title":"Contenedor de base de datos"},{"location":"9_4_desplegar_docker.html#creando-la-imagen-para-el-contenedor-de-nuestra-aplicacion","text":"Clonamos la rama docker del repositorio github donde tenemos los ficheros de nuestra aplicaci\u00f3n: $ git clone https://github.com/josedom24/tienda_videojuegos.git -b docker En el repositorio tenemos un fichero Dockerfile donde definimos las instrucciones que vamos a ejecutar para crear la imagen docker: FROM ubuntu:16.04 MAINTAINER Jos\u00e9 Domingo Mu\u00f1oz RUN apt-get update -y && apt-get install -y \\ apache2 \\ libapache2-mod-wsgi-py3 \\ python3-pip \\ && apt-get clean && rm -rf /var/lib/apt/lists/* ADD /tienda_videojuegos /var/www/html/tienda_videojuegos RUN chown www-data:www-data -R /var/www/html/tienda_videojuegos RUN pip3 install -r /var/www/html/tienda_videojuegos/requirements.txt ADD 000-default.conf /etc/apache2/sites-available/ ADD app.wsgi /var/www/html/tienda_videojuegos RUN service apache2 restart ENV APACHE_RUN_USER www-data ENV APACHE_RUN_GROUP www-data ENV APACHE_LOG_DIR /var/log/apache2 EXPOSE 80 WORKDIR /var/www/html/tienda_videojuegos COPY ./run.sh / ENTRYPOINT [\"/run.sh\"] Tambi\u00e9n tenemos el fichero donde creamos la aplicaci\u00f3n WSGI, app.wsgi : import sys sys.path.insert(0, '/var/www/html/tienda_videojuegos') from aplicacion.app import app as application El fichero de configuraci\u00f3n del virtualhost de apache2: 000-default.conf : ... DocumentRoot /var/www/html/tienda_videojuegos/aplicacion WSGIDaemonProcess tienda user=www-data group=www-data threads=5 WSGIScriptAlias / /var/www/html/tienda_videojuegos/app.wsgi <Directory /var/www/html/tienda_videojuegos/aplicacion> WSGIProcessGroup tienda WSGIApplicationGroup %{GLOBAL} Require all granted </Directory> ... Y por \u00faltimo el fichero run.sh que el script que se va a ejecutar cuando creemos el contenedor: #!/bin/bash python3 manage.py create_tables python3 manage.py add_data_tables /usr/sbin/apache2ctl -D FOREGROUND Creamos las tablas con los datos de ejemplo de la base de datos y ejecutamos el servidor apache2. Para crear la imagen ejecutamos el siguiente comando: $ cd tienda_videojuegos $ sudo docker build -t tienda . Y comprobamos que hemos generado la nueva imagen: $ sudo docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE tienda latest bb1d87c90448 46 hours ago 474MB ubuntu 16.04 ccc7a11d65b1 11 days ago 120MB mysql latest c73c7527c03a 3 weeks ago 412MB","title":"Creando la imagen para el contenedor de nuestra aplicaci\u00f3n"},{"location":"9_4_desplegar_docker.html#contenedor-con-nuestra-aplicacion","text":"Para crear el contenedor con nuestra aplicaci\u00f3n: $ sudo docker run --name mytienda -e MYSQL_PASSWORD=asdasd -p 8080:80 --link servidor_mysql:mysql -d tienda Comprobamos que los contenedores se est\u00e1n ejecutando: $ sudo docker ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 08eadf7d87b0 tienda \"/run.sh\" 4 seconds ago Up 3 seconds 0.0.0.0:8080->80/tcp mytienda 6ccff57702ba mysql \"docker-entrypoint...\" 16 seconds ago Up 16 seconds 3306/tcp servidor_mysql Si queremos crear el usuario administrador de nuestra aplicaci\u00f3n podemos acceder de forma interactiva a nuestro contenedor para ejecutar la instrucci\u00f3n necesaria: $ sudo docker exec -i -t mytienda /bin/bash root@5db96abf79b3:/var/www/html/tienda_videojuegos# python3 manage.py create_admin Por ultimo comprobamos que la aplicaci\u00f3n est\u00e1 funcionando accediendo a la ip del servidor y al puerto 8080:","title":"Contenedor con nuestra aplicaci\u00f3n"}]}